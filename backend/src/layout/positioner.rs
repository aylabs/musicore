//! Glyph positioning
//!
//! Positions glyphs based on pitch (vertical) and timing (horizontal).

use crate::layout::metrics::get_glyph_bbox;
use crate::layout::types::{BoundingBox, Glyph, Point, SourceReference};

/// Convert pitch to y-coordinate on staff
///
/// Uses standard music notation positioning based on clef type and diatonic scale degrees.
/// Staff lines represent the diatonic scale (C-D-E-F-G-A-B), not chromatic semitones.
///
/// Treble clef (G clef) positions:
/// - F5 (MIDI 77) = top line (y=0)
/// - E5 (MIDI 76) = space (y=20)
/// - D5 (MIDI 74) = 2nd line (y=40)
/// - C5 (MIDI 72) = space (y=60)
/// - B4 (MIDI 71) = middle line (y=80)
/// - A4 (MIDI 69) = space (y=100)
/// - G4 (MIDI 67) = 4th line (y=120)
/// - F4 (MIDI 65) = space (y=140)
/// - E4 (MIDI 64) = bottom line (y=160)
///
/// Bass clef (F clef) positions:
/// - A3 (MIDI 57) = top line (y=0)
/// - G3 (MIDI 55) = space (y=20)
/// - F3 (MIDI 53) = 2nd line (y=40)
/// - E3 (MIDI 52) = space (y=60)
/// - D3 (MIDI 50) = middle line (y=80)
/// - C3 (MIDI 48) = space (y=100)
/// - B2 (MIDI 47) = 4th line (y=120)
/// - A2 (MIDI 45) = space (y=140)
/// - G2 (MIDI 43) = bottom line (y=160)
///
/// # Arguments
/// * `pitch` - MIDI pitch number (60 = middle C, 69 = A440)
/// * `clef_type` - Type of clef ("Treble", "Bass", "Alto", "Tenor")
/// * `units_per_space` - Scaling factor (default: 20.0 logical units = 1 staff space)
///
/// # Returns
/// Y-coordinate in logical units (system-relative, positive = downward)
pub fn pitch_to_y(pitch: u8, clef_type: &str, units_per_space: f32) -> f32 {
    // Convert MIDI pitch to diatonic staff position
    // Each octave has 7 diatonic notes (C=0, D=1, E=2, F=3, G=4, A=5, B=6)

    // Map chromatic pitch classes to diatonic letter positions
    // Accidentals (sharps/flats) sit on the same line as their natural note
    // C and C# both at position 0, D and D# at position 1, etc.
    const DIATONIC_POSITIONS: [f32; 12] = [
        0.0, // C
        0.0, // C# (same Y position as C, sharp drawn separately)
        1.0, // D
        1.0, // D# (same Y position as D, sharp drawn separately)
        2.0, // E
        3.0, // F
        3.0, // F# (same Y position as F, sharp drawn separately)
        4.0, // G
        4.0, // G# (same Y position as G, sharp drawn separately)
        5.0, // A
        5.0, // A# (same Y position as A, sharp drawn separately)
        6.0, // B
    ];

    let pitch_class = (pitch % 12) as usize;
    // MIDI octave: C(-1) = 0, C0 = 12, C1 = 24, C5 = 60, etc.
    // So octave number = (pitch / 12) - 1, but we count from C(-1) as octave 0 for calculation
    let octave = (pitch / 12) as i32;

    // Calculate diatonic position within octave
    let diatonic_pos_in_octave = DIATONIC_POSITIONS[pitch_class];

    // Total diatonic steps from C(-1) (MIDI 0)
    let diatonic_steps_from_c_minus1 = (octave * 7) as f32 + diatonic_pos_in_octave;

    // Determine reference pitch for top line based on clef type
    let reference_diatonic = match clef_type {
        "Bass" => {
            // Bass clef: A3 (MIDI 57) = top line at y=0
            // MIDI 57: octave = 57/12 = 4, pitch_class = 57%12 = 9 (A)
            // Diatonic position: 4 * 7 + 5 (A=5) = 33 diatonic steps from C(-1)
            4.0 * 7.0 + 5.0 // = 33
        }
        "Alto" => {
            // Alto clef: G4 (MIDI 67) = top line at y=0
            // MIDI 67: octave = 67/12 = 5, pitch_class = 67%12 = 7 (G)
            // Diatonic position: 5 * 7 + 4 (G=4) = 39 diatonic steps from C(-1)
            5.0 * 7.0 + 4.0 // = 39
        }
        "Tenor" => {
            // Tenor clef: E4 (MIDI 64) = top line at y=0
            // MIDI 64: octave = 64/12 = 5, pitch_class = 64%12 = 4 (E)
            // Diatonic position: 5 * 7 + 2 (E=2) = 37 diatonic steps from C(-1)
            5.0 * 7.0 + 2.0 // = 37
        }
        _ => {
            // Treble clef (default): F5 (MIDI 77) = top line at y=0
            // MIDI 77: octave = 77/12 = 6, pitch_class = 77%12 = 5 (F)
            // Diatonic position: 6 * 7 + 3 (F=3) = 45 diatonic steps from C(-1)
            6.0 * 7.0 + 3.0 // = 45
        }
    };

    // Staff spaces from reference pitch (down = positive)
    // Each diatonic step = 1 staff space
    let staff_spaces_from_reference = reference_diatonic - diatonic_steps_from_c_minus1;

    // Convert to logical units, offset by -0.5 spaces to center noteheads on staff lines
    // This compensates for SMuFL glyph baseline positioning
    (staff_spaces_from_reference - 0.5) * units_per_space
}

/// Compute glyph bounding box using SMuFL metrics
///
/// Fetches glyph metrics from embedded Bravura font and scales to font size
///
/// # Arguments
/// * `glyph_name` - SMuFL glyph name (e.g., "noteheadBlack")
/// * `position` - (x, y) coordinates of glyph anchor point
/// * `font_size` - Font size in logical units (typically 40.0 = 4 staff spaces)
/// * `units_per_space` - Scaling factor
///
/// # Returns
/// Bounding box in logical units relative to system coordinates
pub fn compute_glyph_bounding_box(
    glyph_name: &str,
    position: &Point,
    font_size: f32,
    units_per_space: f32,
) -> BoundingBox {
    let metrics_bbox = get_glyph_bbox(glyph_name);

    // Scale metrics bbox by font size / units_per_space
    let scale = font_size / (4.0 * units_per_space); // Font size is in 4 staff spaces

    BoundingBox {
        x: position.x + metrics_bbox.x * scale,
        y: position.y + metrics_bbox.y * scale,
        width: metrics_bbox.width * scale,
        height: metrics_bbox.height * scale,
    }
}

/// Position noteheads for a set of notes
///
/// Creates Glyph structs for noteheads using pitch-to-y mapping and horizontal spacing
///
/// # Arguments
/// * `notes` - Note events with pitch, start_tick, duration
/// * `horizontal_offsets` - Pre-computed x offsets for each note
/// * `clef_type` - Type of clef for pitch positioning ("Treble", "Bass", etc.)
/// * `units_per_space` - Scaling factor
/// * `instrument_id` - Instrument ID for source reference
/// * `staff_index` - Staff index for source reference
/// * `voice_index` - Voice index for source reference
/// * `staff_vertical_offset` - Vertical offset in logical units for this staff
///
/// # Returns
/// Vector of positioned glyph structs
#[allow(clippy::too_many_arguments)]
pub fn position_noteheads(
    notes: &[(u8, u32, u32)], // (pitch, start_tick, duration)
    horizontal_offsets: &[f32],
    clef_type: &str,
    units_per_space: f32,
    instrument_id: &str,
    staff_index: usize,
    voice_index: usize,
    staff_vertical_offset: f32,
) -> Vec<Glyph> {
    notes
        .iter()
        .zip(horizontal_offsets.iter())
        .enumerate()
        .map(|(i, ((pitch, _start, duration), &x))| {
            let y = pitch_to_y(*pitch, clef_type, units_per_space) + staff_vertical_offset;
            let position = Point { x, y };

            // T021-T022: Choose notehead codepoint based on duration_ticks
            // Duration mapping (assuming 960 PPQ = 1 beat):
            // - Whole note (4 beats): 3840+ ticks → U+E0A2 noteheadWhole (no stem)
            // - Half note (2 beats): 1920-3839 ticks → U+E1D3 noteheadHalfWithStem (open oval + stem)
            // - Quarter note (1 beat): 960-1919 ticks → U+E1D5 noteheadBlackWithStem (filled oval + stem, no flag)
            // - Eighth note (1/2 beat): 480-959 ticks → U+E1D7 noteEighthUp (filled oval + stem + single flag)
            // - Sixteenth note (1/4 beat): <480 ticks → U+E1D9 noteSixteenthUp (filled oval + stem + double flag)
            let (codepoint, glyph_name) = if *duration >= 3840 {
                ('\u{E0A2}', "noteheadWhole")
            } else if *duration >= 1920 {
                ('\u{E1D3}', "noteheadHalfWithStem")
            } else if *duration >= 960 {
                ('\u{E1D5}', "noteheadBlackWithStem")
            } else if *duration >= 480 {
                ('\u{E1D7}', "noteEighthUp")
            } else {
                ('\u{E1D9}', "noteSixteenthUp")
            };

            let bounding_box = compute_glyph_bounding_box(
                glyph_name,
                &position,
                40.0, // Standard font size
                units_per_space,
            );

            Glyph {
                position,
                bounding_box,
                codepoint: codepoint.to_string(),
                source_reference: SourceReference {
                    instrument_id: instrument_id.to_string(),
                    staff_index,
                    voice_index,
                    event_index: i,
                },
            }
        })
        .collect()
}

/// Position clef at system start (T030-T031)
///
/// Places clef glyph at specified x-position with correct vertical alignment for clef type.
///
/// # Arguments
/// * `clef_type` - Type of clef ("Treble", "Bass", "Alto", "Tenor")
/// * `x_position` - Horizontal position in logical units
/// * `units_per_space` - Scaling factor (20 units = 1 staff space)
/// * `staff_vertical_offset` - Vertical offset in logical units for this staff
///
/// # Returns
/// Glyph positioned at correct location with appropriate SMuFL codepoint
pub fn position_clef(
    clef_type: &str,
    x_position: f32,
    units_per_space: f32,
    staff_vertical_offset: f32,
) -> Glyph {
    // SMuFL codepoints for clefs
    let (codepoint, y_position) = match clef_type {
        "Treble" => {
            // G clef centered on 2nd line (G4 line at y=120)
            // With -0.5 offset: y=110
            ('\u{E050}', 110.0)
        }
        "Bass" => {
            // F clef centered on 4th line (F3 line at y=120)
            // With -0.5 offset: y=110
            ('\u{E062}', 110.0)
        }
        "Alto" => {
            // C clef centered on 3rd line (C4, middle line at y=80)
            // With -0.5 offset: y=70
            ('\u{E05C}', 70.0)
        }
        "Tenor" => {
            // C clef centered on 4th line (A3 line at y=120)
            // With -0.5 offset: y=110
            ('\u{E05D}', 110.0)
        }
        _ => {
            // Default to treble clef
            ('\u{E050}', 110.0)
        }
    };

    let position = Point {
        x: x_position,
        y: y_position + staff_vertical_offset,
    };

    let bounding_box = compute_glyph_bounding_box(
        "gClef", // Generic name for metrics lookup
        &position,
        40.0,
        units_per_space,
    );

    Glyph {
        position,
        bounding_box,
        codepoint: codepoint.to_string(),
        source_reference: SourceReference {
            instrument_id: "structural".to_string(),
            staff_index: 0,
            voice_index: 0,
            event_index: 0,
        },
    }
}

/// Position time signature at system start (T032-T033)
///
/// Creates two stacked glyphs for numerator and denominator.
///
/// # Arguments
/// * `numerator` - Top number (beats per measure)
/// * `denominator` - Bottom number (note value)
/// * `x_position` - Horizontal position in logical units
/// * `units_per_space` - Scaling factor
/// * `staff_vertical_offset` - Vertical offset in logical units for this staff
///
/// # Returns
/// Vector of 2 glyphs (numerator above middle line, denominator below)
pub fn position_time_signature(
    numerator: u8,
    denominator: u8,
    x_position: f32,
    units_per_space: f32,
    staff_vertical_offset: f32,
) -> Vec<Glyph> {
    let mut glyphs = Vec::new();

    // SMuFL time signature digits: U+E080-U+E089 (0-9)
    let numerator_codepoint = char::from_u32(0xE080 + numerator as u32).unwrap_or('?');
    let denominator_codepoint = char::from_u32(0xE080 + denominator as u32).unwrap_or('?');

    // Numerator above middle line (y=30, which is 1.5 staff spaces above middle)
    let numerator_pos = Point {
        x: x_position,
        y: 30.0 + staff_vertical_offset,
    };

    let numerator_bbox =
        compute_glyph_bounding_box("timeSig0", &numerator_pos, 40.0, units_per_space);

    glyphs.push(Glyph {
        position: numerator_pos,
        bounding_box: numerator_bbox,
        codepoint: numerator_codepoint.to_string(),
        source_reference: SourceReference {
            instrument_id: "structural".to_string(),
            staff_index: 0,
            voice_index: 0,
            event_index: 0,
        },
    });

    // Denominator below middle line (y=110, which is 1.5 staff spaces below middle)
    let denominator_pos = Point {
        x: x_position,
        y: 110.0 + staff_vertical_offset,
    };

    let denominator_bbox =
        compute_glyph_bounding_box("timeSig0", &denominator_pos, 40.0, units_per_space);

    glyphs.push(Glyph {
        position: denominator_pos,
        bounding_box: denominator_bbox,
        codepoint: denominator_codepoint.to_string(),
        source_reference: SourceReference {
            instrument_id: "structural".to_string(),
            staff_index: 0,
            voice_index: 0,
            event_index: 0,
        },
    });

    glyphs
}

/// Position key signature accidentals (T034-T035)
///
/// Places sharps or flats at correct staff positions for the given clef type.
///
/// # Arguments
/// * `sharps` - Number of sharps (positive) or flats (negative), 0 for C major/A minor
/// * `clef_type` - Type of clef determines vertical positions
/// * `x_start` - Starting horizontal position
/// * `units_per_space` - Scaling factor
/// * `staff_vertical_offset` - Vertical offset in logical units for this staff
///
/// # Returns
/// Vector of glyphs positioned at correct line/space positions
pub fn position_key_signature(
    sharps: i8,
    _clef_type: &str,
    x_start: f32,
    units_per_space: f32,
    staff_vertical_offset: f32,
) -> Vec<Glyph> {
    let mut glyphs = Vec::new();

    if sharps == 0 {
        return glyphs; // C major/A minor has no accidentals
    }

    // SMuFL accidental glyphs
    let codepoint = if sharps > 0 {
        '\u{E262}' // accidentalSharp
    } else {
        '\u{E260}' // accidentalFlat
    };

    // Treble clef sharp positions (F C G D A E B)
    // F5 (top line), C5 (space), G5 (above staff), D5 (2nd line), A4 (space), E5 (space), B4 (middle)
    let treble_sharp_positions = vec![-10.0, 50.0, -30.0, 30.0, 90.0, 10.0, 70.0];

    // Treble clef flat positions (B E A D G C F)
    // B4 (middle line), E5 (space), A4 (space), D5 (2nd line), G4 (4th line), C5 (space), F4 (space)
    let treble_flat_positions = vec![70.0, 10.0, 90.0, 30.0, 110.0, 50.0, 130.0];

    // Select positions based on sharps/flats and clef type
    let positions = if sharps > 0 {
        &treble_sharp_positions // Use sharps
    } else {
        &treble_flat_positions // Use flats
    };

    let count = sharps.unsigned_abs() as usize;
    let horizontal_spacing = 15.0; // Space between accidentals

    for (i, &y_pos) in positions
        .iter()
        .enumerate()
        .take(count.min(positions.len()))
    {
        let position = Point {
            x: x_start + (i as f32 * horizontal_spacing),
            y: y_pos + staff_vertical_offset,
        };

        let bbox = compute_glyph_bounding_box("accidentalSharp", &position, 40.0, units_per_space);

        glyphs.push(Glyph {
            position,
            bounding_box: bbox,
            codepoint: codepoint.to_string(),
            source_reference: SourceReference {
                instrument_id: "structural".to_string(),
                staff_index: 0,
                voice_index: 0,
                event_index: 0,
            },
        });
    }

    glyphs
}

/// Position accidentals before noteheads
///
/// Determines which notes need accidentals based on key signature and
/// measure context, then creates positioned glyph structs.
///
/// Accidental rules:
/// - Notes altered from the key signature need an accidental
/// - Accidentals carry through the measure (same pitch = no repeat)
/// - A natural sign cancels a key signature accidental
/// - Barline boundaries (every 3840 ticks in 4/4) reset accidental state
///
/// # Arguments
/// * `notes` - Note events (pitch, start_tick, duration)
/// * `horizontal_offsets` - Pre-computed x offsets for each note
/// * `clef_type` - Clef type for pitch positioning
/// * `units_per_space` - Scaling factor
/// * `instrument_id` - Instrument ID for source reference
/// * `staff_index` - Staff index for source reference
/// * `voice_index` - Voice index for source reference
/// * `staff_vertical_offset` - Vertical offset for this staff
/// * `key_sharps` - Key signature (positive = sharps, negative = flats, 0 = C major)
///
/// # Returns
/// Vector of accidental glyphs positioned to the left of their noteheads
#[allow(clippy::too_many_arguments)]
pub fn position_note_accidentals(
    notes: &[(u8, u32, u32)],
    horizontal_offsets: &[f32],
    clef_type: &str,
    units_per_space: f32,
    instrument_id: &str,
    staff_index: usize,
    voice_index: usize,
    staff_vertical_offset: f32,
    key_sharps: i8,
) -> Vec<Glyph> {
    use std::collections::HashMap;

    // Build set of pitch classes affected by key signature
    // Sharp order: F C G D A E B (pitch classes: 5,0,7,2,9,4,11)
    // Flat order:  B E A D G C F (pitch classes: 11,4,9,2,7,0,5)
    let sharp_order: [u8; 7] = [5, 0, 7, 2, 9, 4, 11]; // F, C, G, D, A, E, B
    let flat_order: [u8; 7] = [11, 4, 9, 2, 7, 0, 5]; // B, E, A, D, G, C, F

    // key_alterations maps pitch_class -> alteration (+1 = sharp, -1 = flat)
    let mut key_alterations: HashMap<u8, i8> = HashMap::new();
    if key_sharps > 0 {
        for &pc in sharp_order.iter().take(key_sharps as usize) {
            key_alterations.insert(pc, 1);
        }
    } else if key_sharps < 0 {
        for &pc in flat_order.iter().take(key_sharps.unsigned_abs() as usize) {
            key_alterations.insert(pc, -1);
        }
    }

    // Map pitch classes to their "natural" (white key) MIDI value
    // C=0, D=2, E=4, F=5, G=7, A=9, B=11
    let natural_pitch_classes: [u8; 12] = [
        0,  // C  -> natural = C(0)
        0,  // C# -> natural = C(0), so alteration = +1
        2,  // D  -> natural = D(2)
        2,  // D# -> natural = D(2), so alteration = +1
        4,  // E  -> natural = E(4)
        5,  // F  -> natural = F(5)
        5,  // F# -> natural = F(5), so alteration = +1
        7,  // G  -> natural = G(7)
        7,  // G# -> natural = G(7), so alteration = +1
        9,  // A  -> natural = A(9)
        9,  // A# -> natural = A(9), so alteration = +1
        11, // B  -> natural = B(11)
    ];

    // Compute the chromatic alteration of each pitch class
    // 0 = natural, +1 = sharp, -1 = flat
    let chromatic_alteration: [i8; 12] = [
        0, // C  = natural
        1, // C# = sharp
        0, // D  = natural
        1, // D# = sharp (enharmonic Eb = flat, but MIDI doesn't distinguish)
        0, // E  = natural
        0, // F  = natural
        1, // F# = sharp
        0, // G  = natural
        1, // G# = sharp (enharmonic Ab = flat)
        0, // A  = natural
        1, // A# = sharp (enharmonic Bb = flat)
        0, // B  = natural
    ];

    // For flats in the key signature, we need to interpret certain pitch classes as flats
    // E.g., in F major (1 flat = Bb), MIDI pitch class 10 is Bb (flat), not A#
    // The key signature tells us which way to spell ambiguous pitches

    let mut accidental_glyphs = Vec::new();

    // Track accidentals stated so far in the current measure
    // Maps pitch_class -> last stated alteration in this measure
    let mut measure_accidental_state: HashMap<u8, i8> = HashMap::new();
    let mut current_measure: u32 = u32::MAX; // Force reset on first note

    // Position accidental to the left of notehead.
    // Both accidental and notehead use text-anchor:middle in SVG rendering,
    // so the offset must account for half-widths of both glyphs plus a gap.
    // At font-size 80: notehead ~23.6 units wide (half=11.8),
    // sharp ~23.6 units wide (half=11.8), standard gap ~5 units.
    // Total center-to-center offset: -(11.8 + 5 + 11.8) ≈ -29
    let accidental_x_offset = -29.0;

    for (i, ((pitch, start_tick, _duration), &notehead_x)) in
        notes.iter().zip(horizontal_offsets.iter()).enumerate()
    {
        let pitch = *pitch;
        let start_tick = *start_tick;
        let pitch_class = pitch % 12;

        // Check for measure boundary (reset accidental state)
        let measure = start_tick / 3840;
        if measure != current_measure {
            measure_accidental_state.clear();
            current_measure = measure;
        }

        // Determine the note's actual alteration
        let note_alteration = chromatic_alteration[pitch_class as usize];

        // What does the key signature say about this pitch class's diatonic note?
        let diatonic_pc = natural_pitch_classes[pitch_class as usize];
        let _key_says = key_alterations.get(&diatonic_pc).copied().unwrap_or(0);

        // For flat keys: if the key says sharp on a diatonic note, that means the
        // pitch class one semitone up is the default. But we deal with it differently:
        // In flat keys, check if the key signature covers this specific pitch class.
        // E.g. key of F (1 flat = Bb): diatonic B (pc=11) is flatted to Bb (pc=10)
        // So for pc=10, key_says for diatonic_pc=9(A)? No...
        //
        // Let's simplify: determine if the note needs an accidental by checking
        // whether the key signature already accounts for this note's sound.

        // A note needs an accidental if:
        // 1. It has an alteration not covered by the key signature, OR
        // 2. It is natural but the key signature would alter it (needs a natural sign)

        let needs_accidental;
        let accidental_type: i8; // +1=sharp, -1=flat, 0=natural

        if key_sharps > 0 {
            // Sharp key: key signature sharps certain diatonic notes
            if key_alterations.contains_key(&pitch_class) {
                // This pitch class IS a sharp in the key (e.g., F# in G major)
                // The note should sound as this pitch naturally, no accidental needed
                needs_accidental = false;
                accidental_type = 0;
            } else if note_alteration == 1 {
                // Note is sharp but NOT in key signature → needs explicit sharp
                needs_accidental = true;
                accidental_type = 1; // sharp
            } else if note_alteration == 0 {
                // Natural note — check if key signature sharpens this diatonic note
                if key_alterations.contains_key(&pitch_class) {
                    // Already handled above (unreachable here)
                    needs_accidental = false;
                    accidental_type = 0;
                } else {
                    // Check if this diatonic note is sharped by key sig
                    // e.g., in G major, F is sharped → natural F needs a natural sign
                    // pitch_class is the diatonic (natural) pitch class
                    // Check if key_alterations has an entry that would sharpen this note
                    let is_sharped_by_key = key_alterations.contains_key(&pitch_class);
                    if is_sharped_by_key {
                        needs_accidental = true;
                        accidental_type = 0; // natural
                    } else {
                        needs_accidental = false;
                        accidental_type = 0;
                    }
                }
            } else {
                // Flat note in a sharp key → always needs accidental
                needs_accidental = true;
                accidental_type = -1;
            }
        } else if key_sharps < 0 {
            // Flat key: key signature flats certain diatonic notes
            // E.g., F major (1 flat): B is flatted to Bb
            // In flat keys, the flattened pitch classes are:
            // flat_order gives the diatonic notes that get flatted
            // The SOUNDING pitch class of a flatted note = diatonic_pc - 1
            let flatted_sounding: Vec<u8> = flat_order
                .iter()
                .take(key_sharps.unsigned_abs() as usize)
                .map(|&pc| (pc + 12 - 1) % 12) // B(11)->Bb(10), E(4)->Eb(3), etc.
                .collect();

            if flatted_sounding.contains(&pitch_class) {
                // This note is a flat that's in the key signature → no accidental
                needs_accidental = false;
                accidental_type = 0;
            } else if note_alteration == 0 {
                // Natural note — check if key would flat the diatonic version
                let diatonic_is_flatted = flat_order
                    .iter()
                    .take(key_sharps.unsigned_abs() as usize)
                    .any(|&pc| pc == pitch_class);
                if diatonic_is_flatted {
                    // e.g., B natural in key of F (where B is normally flatted) → needs natural
                    needs_accidental = true;
                    accidental_type = 0; // natural
                } else {
                    needs_accidental = false;
                    accidental_type = 0;
                }
            } else if note_alteration == 1 {
                // Sharp note in flat key → needs sharp accidental
                needs_accidental = true;
                accidental_type = 1;
            } else {
                // Flat note not in key signature → needs explicit flat
                needs_accidental = true;
                accidental_type = -1;
            }
        } else {
            // C major / A minor: no key signature accidentals
            if note_alteration != 0 {
                needs_accidental = true;
                accidental_type = note_alteration;
            } else {
                needs_accidental = false;
                accidental_type = 0;
            }
        }

        if !needs_accidental {
            continue;
        }

        // Check measure-scoped state: skip if same accidental already stated for this pitch
        if let Some(&prev) = measure_accidental_state.get(&pitch_class) {
            if prev == accidental_type {
                continue; // Already stated this accidental in this measure
            }
        }

        // Record this accidental in the measure state
        measure_accidental_state.insert(pitch_class, accidental_type);

        // Choose SMuFL codepoint
        let (codepoint, glyph_name) = match accidental_type {
            1 => ('\u{E262}', "accidentalSharp"),
            -1 => ('\u{E260}', "accidentalFlat"),
            _ => ('\u{E261}', "accidentalNatural"),
        };

        // Position accidental at same Y as notehead, offset to the left
        let y = pitch_to_y(pitch, clef_type, units_per_space) + staff_vertical_offset;
        let position = Point {
            x: notehead_x + accidental_x_offset,
            y,
        };

        let bounding_box = compute_glyph_bounding_box(glyph_name, &position, 40.0, units_per_space);

        accidental_glyphs.push(Glyph {
            position,
            bounding_box,
            codepoint: codepoint.to_string(),
            source_reference: SourceReference {
                instrument_id: instrument_id.to_string(),
                staff_index,
                voice_index,
                event_index: i,
            },
        });
    }

    accidental_glyphs
}

/// Position structural glyphs (clefs, key sigs, time sigs) at system start
///
/// Stub for now - will be implemented when needed
pub fn position_structural_glyphs() {
    // Stub implementation - structural glyphs positioning
    // For MVP, we'll skip structural glyphs and implement this in future iterations
}

#[cfg(test)]
mod tests {
    use super::*;

    /// T017: Unit test for pitch_to_y() with correct treble clef positions
    #[test]
    fn test_pitch_to_y_treble_staff() {
        let units_per_space = 20.0;

        // Treble staff lines (from top to bottom), with -0.5 offset for glyph centering:
        // F5 (MIDI 77) = top line at y=-10
        assert_eq!(
            pitch_to_y(77, "Treble", units_per_space),
            -10.0,
            "F5 should be on top line (y=-10)"
        );

        // D5 (MIDI 74) = 2nd line at y=30
        assert_eq!(
            pitch_to_y(74, "Treble", units_per_space),
            30.0,
            "D5 should be on 2nd line (y=30)"
        );

        // B4 (MIDI 71) = 3rd line at y=70
        assert_eq!(
            pitch_to_y(71, "Treble", units_per_space),
            70.0,
            "B4 should be on 3rd line (y=70)"
        );

        // G4 (MIDI 67) = 4th line at y=110
        assert_eq!(
            pitch_to_y(67, "Treble", units_per_space),
            110.0,
            "G4 should be on 4th line (y=110)"
        );

        // E4 (MIDI 64) = bottom line at y=150
        assert_eq!(
            pitch_to_y(64, "Treble", units_per_space),
            150.0,
            "E4 should be on bottom line (y=150)"
        );

        // C5 (MIDI 72) = space between 2nd and 3rd lines at y=50
        assert_eq!(
            pitch_to_y(72, "Treble", units_per_space),
            50.0,
            "C5 should be in space (y=50)"
        );

        // Middle C4 (MIDI 60) = ledger line below staff at y=190
        assert_eq!(
            pitch_to_y(60, "Treble", units_per_space),
            190.0,
            "Middle C should be below staff (y=190)"
        );

        // G5 (MIDI 79) = space above top line at y=-30
        assert_eq!(
            pitch_to_y(79, "Treble", units_per_space),
            -30.0,
            "G5 should be above staff (y=-30)"
        );
    }

    /// T017: Test pitch_to_y() with different units_per_space values
    #[test]
    fn test_pitch_to_y_scale_independence() {
        let pitch = 60; // Middle C4 (ledger line below treble staff)

        // With units_per_space = 20, C4 should be 9.5 spaces below F5 = 190 units
        assert_eq!(pitch_to_y(pitch, "Treble", 20.0), 190.0);

        // With units_per_space = 10, C4 should be 9.5 spaces below F5 = 95 units
        assert_eq!(pitch_to_y(pitch, "Treble", 10.0), 95.0);

        // With units_per_space = 25, C4 should be 9.5 spaces below F5 = 237.5 units
        assert_eq!(pitch_to_y(pitch, "Treble", 25.0), 237.5);
    }

    /// T018: Unit test for notehead codepoint selection based on duration
    #[test]
    fn test_notehead_codepoint_by_duration() {
        // Define test cases: (duration_ticks, expected_codepoint, note_name)
        let test_cases = vec![
            (3840, '\u{E0A2}', "whole note"),    // 4 beats at 960 PPQ
            (1920, '\u{E0A3}', "half note"),     // 2 beats at 960 PPQ
            (960, '\u{E0A4}', "quarter note"),   // 1 beat at 960 PPQ
            (480, '\u{E0A4}', "eighth note"),    // 0.5 beat (should use filled notehead)
            (240, '\u{E0A4}', "sixteenth note"), // 0.25 beat (should use filled notehead)
        ];

        for (duration_ticks, expected_codepoint, note_name) in test_cases {
            let codepoint = get_notehead_codepoint(duration_ticks);
            assert_eq!(
                codepoint, expected_codepoint,
                "{} (duration={}) should use codepoint {:?}",
                note_name, duration_ticks, expected_codepoint
            );
        }
    }

    /// T018: Helper function for notehead codepoint selection
    /// This will be integrated into position_noteheads() in T021-T022
    fn get_notehead_codepoint(duration_ticks: u32) -> char {
        if duration_ticks >= 3840 {
            '\u{E0A2}' // U+E0A2 noteheadWhole
        } else if duration_ticks >= 1920 {
            '\u{E0A3}' // U+E0A3 noteheadHalf
        } else {
            '\u{E0A4}' // U+E0A4 noteheadBlack (quarter, eighth, sixteenth, etc.)
        }
    }

    /// T019: Integration test for notehead positioning
    #[test]
    fn test_position_noteheads_integration() {
        let units_per_space = 20.0;
        let notes = vec![
            (60, 0, 960),    // Middle C, quarter note
            (62, 960, 960),  // D4, quarter note
            (64, 1920, 960), // E4, quarter note
        ];
        let horizontal_offsets = vec![0.0, 100.0, 200.0];

        let glyphs = position_noteheads(
            &notes,
            &horizontal_offsets,
            "Treble",
            units_per_space,
            "test-instrument",
            0,
            0,
            0.0, // staff_vertical_offset
        );

        // Verify correct number of glyphs
        assert_eq!(glyphs.len(), 3, "Should produce 3 noteheads");

        // Verify first notehead (Middle C4 at x=0)
        // C4 = ledger line below staff, 9.5 staff spaces below F5
        assert_eq!(glyphs[0].position.x, 0.0, "First note x-position");
        assert_eq!(glyphs[0].position.y, 190.0, "Middle C4 should be at y=190");
        assert_eq!(
            glyphs[0].codepoint,
            String::from('\u{E1D5}'),
            "Quarter note uses black notehead with stem"
        );

        // Verify second notehead (D4 at x=100)
        // D4 = 8.5 staff spaces below F5
        assert_eq!(glyphs[1].position.x, 100.0, "Second note x-position");
        assert_eq!(glyphs[1].position.y, 170.0, "D4 should be at y=170");

        // Verify third notehead (E4 at x=200)
        // E4 = bottom line, 7.5 staff spaces below F5
        assert_eq!(glyphs[2].position.x, 200.0, "Third note x-position");
        assert_eq!(
            glyphs[2].position.y, 150.0,
            "E4 should be on bottom line (y=150)"
        );
    }

    /// T026: Unit test for position_clef() with various clef types
    #[test]
    fn test_position_clef_treble() {
        let units_per_space = 20.0;
        let x_position = 20.0;

        let glyph = position_clef("Treble", x_position, units_per_space, 0.0);

        // Treble clef should be on 2nd line (G4 line)
        // 2nd line is at y=40 (with -0.5 offset: 30)
        assert_eq!(glyph.position.x, 20.0, "Treble clef x-position");
        assert_eq!(
            glyph.position.y, 110.0,
            "Treble clef centered on 2nd line (G4)"
        );
        assert_eq!(
            glyph.codepoint,
            String::from('\u{E050}'),
            "Treble clef codepoint"
        );
    }

    #[test]
    fn test_position_clef_bass() {
        let units_per_space = 20.0;
        let x_position = 20.0;

        let glyph = position_clef("Bass", x_position, units_per_space, 0.0);

        // Bass clef should be on 4th line (F3 line)
        // 4th line is at y=120 (with -0.5 offset: 110)
        assert_eq!(glyph.position.x, 20.0, "Bass clef x-position");
        assert_eq!(
            glyph.position.y, 110.0,
            "Bass clef centered on 4th line (F3)"
        );
        assert_eq!(
            glyph.codepoint,
            String::from('\u{E062}'),
            "Bass clef codepoint"
        );
    }

    #[test]
    fn test_position_clef_alto() {
        let units_per_space = 20.0;
        let x_position = 20.0;

        let glyph = position_clef("Alto", x_position, units_per_space, 0.0);

        // Alto clef should be centered on middle line (C4)
        // Middle line is at y=80 (with -0.5 offset: 70)
        assert_eq!(glyph.position.x, 20.0, "Alto clef x-position");
        assert_eq!(
            glyph.position.y, 70.0,
            "Alto clef centered on middle line (C4)"
        );
        assert_eq!(
            glyph.codepoint,
            String::from('\u{E05C}'),
            "Alto clef codepoint"
        );
    }

    #[test]
    fn test_position_clef_tenor() {
        let units_per_space = 20.0;
        let x_position = 20.0;

        let glyph = position_clef("Tenor", x_position, units_per_space, 0.0);

        // Tenor clef should be centered on 4th line (A3)
        // 4th line is at y=120 (with -0.5 offset: 110)
        assert_eq!(glyph.position.x, 20.0, "Tenor clef x-position");
        assert_eq!(
            glyph.position.y, 110.0,
            "Tenor clef centered on 4th line (A3)"
        );
        assert_eq!(
            glyph.codepoint,
            String::from('\u{E05D}'),
            "Tenor clef codepoint"
        );
    }

    /// T027: Unit test for position_time_signature() with stacked digits
    #[test]
    fn test_position_time_signature_4_4() {
        let units_per_space = 20.0;
        let x_position = 100.0;

        let glyphs = position_time_signature(4, 4, x_position, units_per_space, 0.0);

        // Should return 2 glyphs (numerator and denominator)
        assert_eq!(
            glyphs.len(),
            2,
            "Time signature has 2 glyphs (numerator + denominator)"
        );

        // Numerator (4) above middle line
        assert_eq!(glyphs[0].position.x, 100.0, "Numerator x-position");
        assert_eq!(glyphs[0].position.y, 30.0, "Numerator above middle line");
        assert_eq!(
            glyphs[0].codepoint,
            String::from('\u{E084}'),
            "Numerator digit 4"
        );

        // Denominator (4) below middle line
        assert_eq!(glyphs[1].position.x, 100.0, "Denominator x-position");
        assert_eq!(glyphs[1].position.y, 110.0, "Denominator below middle line");
        assert_eq!(
            glyphs[1].codepoint,
            String::from('\u{E084}'),
            "Denominator digit 4"
        );
    }

    #[test]
    fn test_position_time_signature_3_4() {
        let units_per_space = 20.0;
        let x_position = 100.0;

        let glyphs = position_time_signature(3, 4, x_position, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 2, "Time signature has 2 glyphs");
        assert_eq!(
            glyphs[0].codepoint,
            String::from('\u{E083}'),
            "Numerator digit 3"
        );
        assert_eq!(
            glyphs[1].codepoint,
            String::from('\u{E084}'),
            "Denominator digit 4"
        );
    }

    #[test]
    fn test_position_time_signature_6_8() {
        let units_per_space = 20.0;
        let x_position = 100.0;

        let glyphs = position_time_signature(6, 8, x_position, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 2, "Time signature has 2 glyphs");
        assert_eq!(
            glyphs[0].codepoint,
            String::from('\u{E086}'),
            "Numerator digit 6"
        );
        assert_eq!(
            glyphs[1].codepoint,
            String::from('\u{E088}'),
            "Denominator digit 8"
        );
    }

    /// T028: Unit test for position_key_signature() with sharps/flats
    #[test]
    fn test_position_key_signature_g_major() {
        let units_per_space = 20.0;
        let x_start = 150.0;

        // G major has 1 sharp (F#)
        let glyphs = position_key_signature(1, "Treble", x_start, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 1, "G major has 1 sharp");
        assert_eq!(glyphs[0].codepoint, String::from('\u{E262}'), "Sharp glyph");
        assert_eq!(glyphs[0].position.x, 150.0, "Sharp x-position");
        // F# in treble clef is on top line
        assert_eq!(glyphs[0].position.y, -10.0, "F# on top line in treble clef");
    }

    #[test]
    fn test_position_key_signature_d_major() {
        let units_per_space = 20.0;
        let x_start = 150.0;

        // D major has 2 sharps (F#, C#)
        let glyphs = position_key_signature(2, "Treble", x_start, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 2, "D major has 2 sharps");
        assert_eq!(glyphs[0].codepoint, String::from('\u{E262}'), "First sharp");
        assert_eq!(
            glyphs[1].codepoint,
            String::from('\u{E262}'),
            "Second sharp"
        );
        // Sharps should be horizontally spaced
        assert!(
            glyphs[1].position.x > glyphs[0].position.x,
            "Sharps spaced horizontally"
        );
    }

    #[test]
    fn test_position_key_signature_f_major() {
        let units_per_space = 20.0;
        let x_start = 150.0;

        // F major has 1 flat (Bb)
        let glyphs = position_key_signature(-1, "Treble", x_start, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 1, "F major has 1 flat");
        assert_eq!(glyphs[0].codepoint, String::from('\u{E260}'), "Flat glyph");
        assert_eq!(glyphs[0].position.x, 150.0, "Flat x-position");
        // Bb in treble clef is on middle line
        assert_eq!(
            glyphs[0].position.y, 70.0,
            "Bb on middle line in treble clef"
        );
    }

    #[test]
    fn test_position_key_signature_c_major() {
        let units_per_space = 20.0;
        let x_start = 150.0;

        // C major has no sharps or flats
        let glyphs = position_key_signature(0, "Treble", x_start, units_per_space, 0.0);

        assert_eq!(glyphs.len(), 0, "C major has no accidentals");
    }
}
