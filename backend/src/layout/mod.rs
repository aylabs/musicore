//! Layout Engine Module
//!
//! Converts a CompiledScore into a deterministic hierarchical spatial model
//! expressed in logical units. The output defines systems as the primary
//! virtualization boundary and provides bounding boxes for efficient rendering,
//! hit testing, and interaction.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub mod batcher;
pub mod beams;
pub mod breaker;
pub mod metrics;
pub mod positioner;
pub mod spacer;
pub mod stems;
pub mod types;

#[cfg(target_arch = "wasm32")]
pub mod wasm;

pub use breaker::MeasureInfo;
pub use types::{
    BarLine, BarLineSegment, BarLineType, BoundingBox, BracketGlyph, BracketType, Color,
    GlobalLayout, Glyph, GlyphRun, LedgerLine, MeasureNumber, Point, SourceReference, Staff,
    StaffGroup, StaffLine, System, TickRange,
};

/// Configuration for layout computation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayoutConfig {
    /// Maximum system width in logical units (default: 1600.0)
    pub max_system_width: f32,
    /// Scaling factor: logical units per staff space (default: 10.0)
    pub units_per_space: f32,
    /// Vertical spacing between systems in logical units (default: 150.0)
    pub system_spacing: f32,
    /// System height in logical units (default: 200.0 for grand staff)
    pub system_height: f32,
}

impl Default for LayoutConfig {
    fn default() -> Self {
        Self {
            max_system_width: 2400.0, // Wide enough for 4-6 measures per system
            units_per_space: 20.0,    // SMuFL: font_size 80 = 4 spaces, so 1 space = 20 units
            system_spacing: 200.0,    // Spacing between systems (gap after system_height)
            system_height: 600.0,     // Height for grand staff with 20 staff spaces separation
        }
    }
}

/// Compute layout from a CompiledScore
///
/// This is the main entry point for the layout engine. Returns a `GlobalLayout`
/// containing the complete spatial model organized into systems.
///
/// # Determinism
///
/// Layout computation is deterministic - identical inputs always produce
/// byte-identical outputs, enabling aggressive caching.
pub fn compute_layout(score: &serde_json::Value, config: &LayoutConfig) -> GlobalLayout {
    // Extract measures from score (simplified - assumes 4/4 time)
    let measures = extract_measures(score);

    // Compute measure widths using spacer
    let spacing_config = spacer::SpacingConfig::default();
    let measure_infos: Vec<breaker::MeasureInfo> = measures
        .iter()
        .enumerate()
        .map(|(i, note_durations)| {
            let width = spacer::compute_measure_width(note_durations, &spacing_config);
            let start_tick = i as u32 * 3840; // 4/4 measure = 3840 ticks
            let end_tick = start_tick + 3840;
            breaker::MeasureInfo {
                width,
                start_tick,
                end_tick,
            }
        })
        .collect();

    // Extract instruments from score (needed before breaking to compute system height)
    let instruments = extract_instruments(score);

    // Compute effective system height based on number of staves.
    // A single staff occupies 8 * units_per_space (5 lines, 4 gaps of 2 spaces each).
    // Each additional staff adds 20 * units_per_space of vertical offset.
    // Add padding for measure numbers above (30 units) and spacing below (10 units).
    let max_staves = instruments
        .iter()
        .map(|i| i.staves.len())
        .max()
        .unwrap_or(1);
    let content_height = (max_staves as f32 - 1.0) * 20.0 * config.units_per_space
        + 8.0 * config.units_per_space
        + 40.0;
    let effective_system_height = config.system_height.max(content_height);

    // Break into systems using effective height that accommodates all staves
    let mut systems = breaker::break_into_systems(
        &measure_infos,
        config.max_system_width,
        effective_system_height,
        config.system_spacing,
    );

    // Populate staff_groups for each system with positioned and batched glyphs
    for system in &mut systems {
        let mut staff_groups = Vec::new();

        for instrument in &instruments {
            let mut staves = Vec::new();

            // Calculate left margin (same for all staves in this instrument)
            let key_sig_width = instrument
                .staves
                .first()
                .map(|s| s.key_sharps.abs() as f32 * 15.0)
                .unwrap_or(0.0);
            let left_margin = 210.0 + key_sig_width;

            // Compute unified note positions across all staves in this instrument (Principle VI)
            // This ensures notes at the same tick align horizontally between treble/bass staves
            let note_positions = compute_unified_note_positions(
                &instrument.staves,
                &system.tick_range,
                system.bounding_box.width,
                left_margin,
                &spacing_config,
            );

            for (staff_index, staff_data) in instrument.staves.iter().enumerate() {
                // Calculate vertical offset for this staff relative to system position
                // Staff spacing: 20 staff spaces between staves (provides clear separation for piano grand staff)
                let staff_vertical_offset =
                    system.bounding_box.y + (staff_index as f32 * 20.0 * config.units_per_space);

                // Position glyphs for this staff using unified note positions
                let glyphs = position_glyphs_for_staff(
                    staff_data,
                    &system.tick_range,
                    config.units_per_space,
                    &instrument.id,
                    staff_index,
                    staff_vertical_offset,
                    &note_positions,
                );

                // Separate pseudo-glyphs (stems U+0000, beams U+0001) from text glyphs
                // so they don't break text batching efficiency. Pseudo-glyphs are
                // rendered as SVG elements, not Canvas text.
                let (text_glyphs, pseudo_glyphs): (Vec<_>, Vec<_>) = glyphs
                    .into_iter()
                    .partition(|g| g.codepoint != "\u{0000}" && g.codepoint != "\u{0001}");

                // Batch text glyphs for efficient rendering
                let mut glyph_runs = batcher::batch_glyphs(text_glyphs);
                // Add pseudo-glyphs as individual runs (each rendered separately)
                glyph_runs.extend(batcher::batch_glyphs(pseudo_glyphs));

                // Create staff lines (5 lines evenly spaced)
                let staff_lines = create_staff_lines(
                    staff_index,
                    system.bounding_box.width,
                    config.units_per_space,
                    system.bounding_box.y,
                );

                // T036-T037: Generate structural glyphs (clef, time sig, key sig) at system start
                let mut structural_glyphs = Vec::new();

                // Position clef at x=60 (left margin with room for brace and glyph extent)
                let clef_glyph = positioner::position_clef(
                    &staff_data.clef,
                    60.0,
                    config.units_per_space,
                    staff_vertical_offset,
                );
                structural_glyphs.push(clef_glyph);

                // Position key signature after clef (x=120)
                let key_sig_glyphs = positioner::position_key_signature(
                    staff_data.key_sharps,
                    &staff_data.clef,
                    120.0,
                    config.units_per_space,
                    staff_vertical_offset,
                );
                structural_glyphs.extend(key_sig_glyphs);

                // Position time signature after key signature
                // Key sig takes ~15 units per accidental, so calculate dynamic x position
                let key_sig_width = staff_data.key_sharps.abs() as f32 * 15.0;
                let time_sig_x = 120.0 + key_sig_width + 20.0; // Add 20 unit gap
                let time_sig_glyphs = positioner::position_time_signature(
                    staff_data.time_numerator,
                    staff_data.time_denominator,
                    time_sig_x,
                    config.units_per_space,
                    staff_vertical_offset,
                );
                structural_glyphs.extend(time_sig_glyphs);

                // Create bar lines at measure boundaries
                let bar_lines = create_bar_lines(
                    &measure_infos,
                    &system.tick_range,
                    staff_index,
                    left_margin,
                    system.bounding_box.width,
                    config.units_per_space,
                    system.bounding_box.y,
                    &note_positions,
                );

                // Generate ledger lines for notes outside the 5-line staff
                let mut ledger_lines = Vec::new();
                for voice in &staff_data.voices {
                    let notes_in_range: Vec<NoteData> = voice
                        .notes
                        .iter()
                        .filter(|note| {
                            note.start_tick >= system.tick_range.start_tick
                                && note.start_tick < system.tick_range.end_tick
                        })
                        .map(|note| {
                            (
                                note.pitch,
                                note.start_tick,
                                note.duration_ticks,
                                note.spelling,
                            )
                        })
                        .collect();
                    let offsets: Vec<f32> = notes_in_range
                        .iter()
                        .map(|(_, tick, _, _)| *note_positions.get(tick).unwrap_or(&0.0))
                        .collect();
                    ledger_lines.extend(positioner::position_ledger_lines(
                        &notes_in_range,
                        &offsets,
                        &staff_data.clef,
                        config.units_per_space,
                        staff_vertical_offset,
                    ));
                }

                // Create staff with batched glyphs and structural glyphs
                let staff = Staff {
                    staff_lines,
                    glyph_runs,
                    structural_glyphs,
                    bar_lines,
                    ledger_lines,
                };

                staves.push(staff);
            }

            // Calculate bracket glyph geometry if multi-staff instrument
            let bracket_type = if instrument.staves.len() > 1 {
                BracketType::Brace
            } else {
                BracketType::None
            };

            let bracket_glyph = if instrument.staves.len() > 1 {
                Some(create_bracket_glyph(&staves, &bracket_type, config))
            } else {
                None
            };

            // Create staff group for this instrument
            let staff_group = StaffGroup {
                instrument_id: instrument.id.clone(),
                staves,
                bracket_type,
                bracket_glyph,
            };

            staff_groups.push(staff_group);
        }

        system.staff_groups = staff_groups;

        // T010: Compute measure number for this system
        // Derive measure number from the system's start tick (3840 ticks per measure in 4/4)
        let measure_num = (system.tick_range.start_tick / 3840) + 1;
        system.measure_number = Some(MeasureNumber {
            number: measure_num,
            position: Point {
                x: 60.0,                         // Aligned with clef
                y: system.bounding_box.y - 30.0, // Above topmost staff line
            },
        });
    }

    // Compute GlobalLayout dimensions
    // Use max_system_width to ensure consistent horizontal scrolling behavior
    // (systems may be narrower if they don't fill the available width)
    let total_width = config.max_system_width;

    let total_height = if systems.is_empty() {
        0.0
    } else {
        let last_system = systems.last().unwrap();
        // Add bottom padding (100 units) so the last system's content
        // (notes below staff, stems, etc.) isn't clipped
        last_system.bounding_box.y + last_system.bounding_box.height + 100.0
    };

    GlobalLayout {
        systems,
        total_width,
        total_height,
        units_per_space: config.units_per_space,
    }
}

/// Extract measures from CompiledScore JSON
///
/// Returns a Vec where each element is a Vec of note durations for that measure.
/// For multi-staff instruments, notes at the same timing position are counted only once
/// (e.g., treble + bass notes sounding together take one horizontal space).
fn extract_measures(score: &serde_json::Value) -> Vec<Vec<u32>> {
    let mut measures: Vec<Vec<u32>> = Vec::new();

    // Extract notes from all instruments
    if let Some(instruments) = score["instruments"].as_array() {
        for instrument in instruments {
            if let Some(staves) = instrument["staves"].as_array() {
                // Collect all unique timing positions across all staves
                // (treble + bass notes at same tick = one horizontal position)
                let mut all_notes_by_measure: std::collections::HashMap<
                    usize,
                    std::collections::HashSet<u32>,
                > = std::collections::HashMap::new();

                for staff in staves {
                    if let Some(voices) = staff["voices"].as_array() {
                        for voice in voices {
                            // Try both "interval_events" (Score format) and "notes" (converted format)
                            let notes_array = voice["interval_events"]
                                .as_array()
                                .or_else(|| voice["notes"].as_array());

                            if let Some(notes) = notes_array {
                                for note in notes {
                                    // Support multiple field name formats:
                                    // Format 1 (Score): start_tick, duration_ticks
                                    // Format 2 (LayoutView): tick, duration
                                    // Format 3 (nested): start_tick.value
                                    let start_tick = note["start_tick"]
                                        .as_u64()
                                        .or_else(|| note["tick"].as_u64())
                                        .or_else(|| note["start_tick"]["value"].as_u64())
                                        .unwrap_or(0)
                                        as u32;

                                    let _duration = note["duration_ticks"]
                                        .as_u64()
                                        .or_else(|| note["duration"].as_u64())
                                        .unwrap_or(960)
                                        as u32;

                                    // Determine which measure this note belongs to (4/4 = 3840 ticks per measure)
                                    let measure_index = (start_tick / 3840) as usize;

                                    // Track unique timing positions (deduplicate simultaneous notes)
                                    all_notes_by_measure
                                        .entry(measure_index)
                                        .or_default()
                                        .insert(start_tick);
                                }
                            }
                        }
                    }
                }

                // Convert unique timing positions to measure durations
                // For simplicity, assume all notes have the same duration (eighth note = 480 ticks)
                for (measure_index, timing_positions) in all_notes_by_measure {
                    // Expand measures vector if needed
                    while measures.len() <= measure_index {
                        measures.push(Vec::new());
                    }

                    // Add one duration entry per unique timing position
                    for _ in 0..timing_positions.len() {
                        measures[measure_index].push(480); // Eighth note duration
                    }
                }
            }
        }
    }

    // If no measures found, return empty default measures
    if measures.is_empty() {
        vec![vec![960; 4]; 10] // 10 measures with 4 quarter notes each
    } else {
        measures
    }
}

/// Represents an instrument with its staves extracted from CompiledScore
#[derive(Debug, Clone)]
struct InstrumentData {
    id: String,
    staves: Vec<StaffData>,
}

/// Represents a staff with voices and notes
#[derive(Debug, Clone)]
struct StaffData {
    voices: Vec<VoiceData>,
    clef: String,         // e.g., "Treble", "Bass", "Alto", "Tenor"
    time_numerator: u8,   // e.g., 4 for 4/4 time
    time_denominator: u8, // e.g., 4 for 4/4 time
    key_sharps: i8,       // Positive for sharps, negative for flats, 0 for C major
}

/// Represents a voice with interval events (notes)
#[derive(Debug, Clone)]
struct VoiceData {
    notes: Vec<NoteEvent>,
}

/// Note data tuple: (pitch, start_tick, duration_ticks, spelling)
///
/// Spelling is an optional (step_letter, alter) pair from MusicXML,
/// e.g. ('E', -1) for Eb, ('D', 1) for D#.
pub type NoteData = (u8, u32, u32, Option<(char, i8)>);

/// Represents a single note event
#[derive(Debug, Clone)]
struct NoteEvent {
    pitch: u8,
    start_tick: u32,
    duration_ticks: u32,
    /// Explicit spelling from MusicXML: (step_letter, alter) e.g. ('E', -1) for Eb
    spelling: Option<(char, i8)>,
    /// Beam annotations from MusicXML import (empty = needs algorithmic grouping)
    beam_info: Vec<(u8, String)>, // (beam_level, beam_type_string)
}

/// Extract instruments from CompiledScore JSON
fn extract_instruments(score: &serde_json::Value) -> Vec<InstrumentData> {
    let mut instruments = Vec::new();

    // DEBUG: Log the entire input to see what we're receiving
    eprintln!(
        "[extract_instruments] Input score: {}",
        serde_json::to_string_pretty(score).unwrap_or_else(|_| "cannot serialize".to_string())
    );

    if let Some(instruments_array) = score["instruments"].as_array() {
        eprintln!(
            "[extract_instruments] Found {} instruments",
            instruments_array.len()
        );
        for instrument in instruments_array {
            let id = instrument["id"].as_str().unwrap_or("unknown").to_string();
            let mut staves = Vec::new();

            if let Some(staves_array) = instrument["staves"].as_array() {
                for staff in staves_array {
                    let mut voices = Vec::new();

                    // Extract structural metadata (with defaults)
                    let clef = staff["clef"].as_str().unwrap_or("Treble").to_string();
                    let time_numerator =
                        staff["time_signature"]["numerator"].as_u64().unwrap_or(4) as u8;
                    let time_denominator =
                        staff["time_signature"]["denominator"].as_u64().unwrap_or(4) as u8;
                    let key_sharps = staff["key_signature"]["sharps"].as_i64().unwrap_or(0) as i8;

                    if let Some(voices_array) = staff["voices"].as_array() {
                        eprintln!(
                            "[extract_instruments] Found {} voices in staff",
                            voices_array.len()
                        );
                        for voice in voices_array {
                            let mut notes = Vec::new();

                            // T008-T009: Support both "notes" (LayoutView format) and "interval_events" (CompiledScore format)
                            // Check "notes" first for frontend fixtures, fall back to "interval_events" for backward compatibility
                            eprintln!(
                                "[extract_instruments] Voice keys: {:?}",
                                voice.as_object().map(|o| o.keys().collect::<Vec<_>>())
                            );

                            let note_array = voice["notes"]
                                .as_array()
                                .or_else(|| voice["interval_events"].as_array());

                            if let Some(notes_data) = note_array {
                                eprintln!(
                                    "[extract_instruments] Found {} notes in voice",
                                    notes_data.len()
                                );
                                for note_item in notes_data {
                                    // Handle both formats:
                                    // Format 1 (notes): {tick: 0, duration: 960, pitch: 60}
                                    // Format 2 (interval_events): {start_tick: {value: 0}, duration_ticks: 960, pitch: {value: 60}}

                                    let pitch = if let Some(p) = note_item["pitch"].as_u64() {
                                        p as u8 // Format 1: direct value
                                    } else {
                                        note_item["pitch"]["value"].as_u64().unwrap_or(60) as u8 // Format 2: nested
                                    };

                                    let start_tick = if let Some(t) = note_item["tick"].as_u64() {
                                        t as u32 // Format 1: "tick"
                                    } else {
                                        note_item["start_tick"]["value"].as_u64().unwrap_or(0)
                                            as u32 // Format 2: nested
                                    };

                                    let duration_ticks = if let Some(d) =
                                        note_item["duration"].as_u64()
                                    {
                                        d as u32 // Format 1: "duration"
                                    } else {
                                        note_item["duration_ticks"].as_u64().unwrap_or(960) as u32 // Format 2
                                    };

                                    // Extract optional note spelling (step + alter) from MusicXML
                                    let spelling = note_item["spelling"]["step"]
                                        .as_str()
                                        .and_then(|s| s.chars().next())
                                        .and_then(|step| {
                                            note_item["spelling"]["alter"]
                                                .as_i64()
                                                .map(|alter| (step, alter as i8))
                                        });

                                    notes.push(NoteEvent {
                                        pitch,
                                        start_tick,
                                        duration_ticks,
                                        spelling,
                                        beam_info: {
                                            let mut beams = Vec::new();
                                            if let Some(beam_array) = note_item["beams"].as_array()
                                            {
                                                for beam_item in beam_array {
                                                    let number =
                                                        beam_item["number"].as_u64().unwrap_or(1)
                                                            as u8;
                                                    let beam_type = beam_item["beam_type"]
                                                        .as_str()
                                                        .unwrap_or("")
                                                        .to_string();
                                                    beams.push((number, beam_type));
                                                }
                                            }
                                            beams
                                        },
                                    });
                                }
                                eprintln!(
                                    "[extract_instruments] Extracted {} notes from voice",
                                    notes.len()
                                );
                            } else {
                                eprintln!(
                                    "[extract_instruments] WARNING: No 'notes' or 'interval_events' array found in voice"
                                );
                            }

                            voices.push(VoiceData { notes });
                        }
                    }

                    staves.push(StaffData {
                        voices,
                        clef,
                        time_numerator,
                        time_denominator,
                        key_sharps,
                    });
                }
            }

            instruments.push(InstrumentData { id, staves });
        }
    }

    instruments
}

/// Compute unified note positions across all staves in a staff group
///
/// For multi-staff instruments (e.g., piano), notes at the same tick must align
/// horizontally across all staves. This function collects all unique tick positions
/// from all staves and computes a unified spacing map.
///
/// # Arguments
/// * `staves` - All staves in the staff group (e.g., treble + bass for piano)
/// * `tick_range` - Tick range for this system
/// * `system_width` - Total system width in logical units
/// * `left_margin` - Left margin for note area
/// * `spacing_config` - Spacing configuration
///
/// # Returns
/// HashMap mapping tick positions to x-coordinates (Principle VI: Layout Engine Authority)
fn compute_unified_note_positions(
    staves: &[StaffData],
    tick_range: &TickRange,
    system_width: f32,
    left_margin: f32,
    spacing_config: &spacer::SpacingConfig,
) -> HashMap<u32, f32> {
    // Collect all unique (tick, duration) pairs from all staves
    let mut tick_durations: Vec<(u32, u32)> = Vec::new();

    for staff_data in staves {
        for voice in &staff_data.voices {
            for note in &voice.notes {
                if note.start_tick >= tick_range.start_tick && note.start_tick < tick_range.end_tick
                {
                    tick_durations.push((note.start_tick, note.duration_ticks));
                }
            }
        }
    }

    if tick_durations.is_empty() {
        return HashMap::new();
    }

    // Sort by tick position and remove duplicates
    tick_durations.sort_by_key(|(tick, _)| *tick);
    tick_durations.dedup_by_key(|(tick, _)| *tick);

    // Calculate cumulative spacing based on durations
    let mut cumulative_spacing = Vec::new();
    let mut current_position = 0.0;
    let mut last_tick = tick_range.start_tick;

    for (start_tick, duration_ticks) in &tick_durations {
        if *start_tick > last_tick {
            let gap_duration = (*start_tick - last_tick).min(*duration_ticks);
            current_position += spacer::compute_note_spacing(gap_duration, spacing_config);
        }
        cumulative_spacing.push(current_position);
        last_tick = *start_tick;
    }

    // Calculate total natural width
    // Add clearance space after last note for notehead width (≈20 units = half the notehead)
    // plus barline spacing (≈10 units) = 30 units total
    let end_clearance = 30.0;
    let total_natural_width = if let Some(&last_pos) = cumulative_spacing.last() {
        let (_, last_duration) = tick_durations.last().unwrap();
        last_pos + spacer::compute_note_spacing(*last_duration, spacing_config) + end_clearance
    } else {
        spacing_config.minimum_spacing + end_clearance
    };

    // Scale positions to fit available width
    let available_width = system_width - left_margin;
    let scale_factor = if total_natural_width > 0.0 {
        available_width / total_natural_width
    } else {
        1.0
    };

    // Build position map: tick -> x_position
    let mut position_map = HashMap::new();
    for (i, (tick, _)) in tick_durations.iter().enumerate() {
        let x_position = left_margin + (cumulative_spacing[i] * scale_factor);
        position_map.insert(*tick, x_position);
    }

    position_map
}

/// Position glyphs for a single staff within a system's tick range
///
/// Uses pre-computed unified note positions to ensure horizontal alignment
/// across all staves in a staff group (e.g., piano treble/bass).
///
/// # Arguments
/// * `staff_data` - Staff data containing voices and notes
/// * `tick_range` - Tick range for this system
/// * `units_per_space` - Scaling factor (20 units = 1 staff space)
/// * `instrument_id` - Instrument identifier
/// * `staff_index` - Index of this staff within the instrument
/// * `staff_vertical_offset` - Vertical offset for this staff
/// * `note_positions` - Pre-computed tick -> x_position map (unified across staves)
fn position_glyphs_for_staff(
    staff_data: &StaffData,
    tick_range: &TickRange,
    units_per_space: f32,
    instrument_id: &str,
    staff_index: usize,
    staff_vertical_offset: f32,
    note_positions: &HashMap<u32, f32>,
) -> Vec<Glyph> {
    let mut all_glyphs = Vec::new();

    for (voice_index, voice) in staff_data.voices.iter().enumerate() {
        // Filter notes that fall within this system's tick range
        let notes_in_range: Vec<NoteData> = voice
            .notes
            .iter()
            .filter(|note| {
                note.start_tick >= tick_range.start_tick && note.start_tick < tick_range.end_tick
            })
            .map(|note| {
                (
                    note.pitch,
                    note.start_tick,
                    note.duration_ticks,
                    note.spelling,
                )
            })
            .collect();

        if notes_in_range.is_empty() {
            continue;
        }

        // Use pre-computed positions from unified spacing (Principle VI)
        let horizontal_offsets: Vec<f32> = notes_in_range
            .iter()
            .map(|(_, start_tick, _, _)| *note_positions.get(start_tick).unwrap_or(&0.0))
            .collect();

        // Position noteheads using positioner module
        // First, compute beam groups to determine which notes are beamed
        let voice_notes_in_range: Vec<&NoteEvent> = voice
            .notes
            .iter()
            .filter(|note| {
                note.start_tick >= tick_range.start_tick && note.start_tick < tick_range.end_tick
            })
            .collect();

        // Build beamable notes with beam info for beam group analysis
        let beamable_for_analysis_raw: Vec<beams::BeamableNote> = voice_notes_in_range
            .iter()
            .enumerate()
            .filter(|(_, note)| note.duration_ticks <= 480) // Only eighth notes and shorter
            .map(|(i, note)| {
                let notehead_x = horizontal_offsets[i];
                let notehead_y =
                    positioner::pitch_to_y(note.pitch, &staff_data.clef, units_per_space)
                        + staff_vertical_offset;

                // Convert beam_info from (number, type_string) to beam_types list
                let beam_types: Vec<String> =
                    note.beam_info.iter().map(|(_, bt)| bt.clone()).collect();
                let beam_levels = note.beam_info.len() as u8;

                beams::BeamableNote {
                    x: notehead_x,
                    y: notehead_y,
                    stem_end_y: 0.0, // Will be computed after stems
                    tick: note.start_tick,
                    duration_ticks: note.duration_ticks,
                    beam_levels,
                    beam_types,
                }
            })
            .collect();

        // Deduplicate chord notes: keep only one entry per tick for beam grouping.
        // Chord notes share a stem, so beaming only needs one note per time position.
        // For the Y position, use the lowest note (highest Y) for stem-down groups
        // and the highest note (lowest Y) for stem-up groups — we'll pick the first
        // occurrence which is sufficient for beam grouping since stem direction is
        // determined later by the group as a whole.
        let mut beamable_for_analysis: Vec<beams::BeamableNote> = Vec::new();
        let mut seen_ticks: std::collections::HashSet<u32> = std::collections::HashSet::new();
        for note in beamable_for_analysis_raw {
            if seen_ticks.insert(note.tick) {
                beamable_for_analysis.push(note);
            }
        }

        // Determine beam groups from MusicXML beam data
        let has_beam_info = beamable_for_analysis
            .iter()
            .any(|n| !n.beam_types.is_empty());
        let beam_groups = if has_beam_info {
            beams::build_beam_groups_from_musicxml(&beamable_for_analysis)
        } else {
            // T041: Algorithmic fallback using time signature-aware beat grouping
            let groups = beams::group_beamable_by_time_signature(
                &beamable_for_analysis,
                staff_data.time_numerator,
                staff_data.time_denominator,
            );
            groups
                .into_iter()
                .map(|notes| beams::BeamGroup {
                    beam_count: 1,
                    notes,
                })
                .collect()
        };

        // Build set of beamed note indices (indices into notes_in_range)
        let mut beamed_note_indices = std::collections::HashSet::<usize>::new();
        // Map tick → ALL note indices at that tick (chords have multiple notes per tick)
        let mut tick_to_indices: std::collections::HashMap<u32, Vec<usize>> =
            std::collections::HashMap::new();
        for (idx, (_, start_tick, duration_ticks, _)) in notes_in_range.iter().enumerate() {
            if *duration_ticks <= 480 {
                tick_to_indices.entry(*start_tick).or_default().push(idx);
            }
        }
        for group in &beam_groups {
            // T050: Skip degenerate single-note groups — they render with flags, not beams
            if group.notes.len() < 2 {
                continue;
            }
            for note in &group.notes {
                if let Some(indices) = tick_to_indices.get(&note.tick) {
                    for &idx in indices {
                        beamed_note_indices.insert(idx);
                    }
                }
            }
        }

        let glyphs = positioner::position_noteheads(
            &notes_in_range,
            &horizontal_offsets,
            &staff_data.clef, // Pass clef type for correct pitch positioning
            units_per_space,
            instrument_id,
            staff_index,
            voice_index,
            staff_vertical_offset,
            &beamed_note_indices,
        );

        all_glyphs.extend(glyphs);

        // Position accidentals based on key signature and measure context
        let accidental_glyphs = positioner::position_note_accidentals(
            &notes_in_range,
            &horizontal_offsets,
            &staff_data.clef,
            units_per_space,
            instrument_id,
            staff_index,
            voice_index,
            staff_vertical_offset,
            staff_data.key_sharps,
        );

        all_glyphs.extend(accidental_glyphs);

        // Generate stems and beams for beamed notes
        // Staff middle line is at y offset: staff_vertical_offset + 4 * units_per_space (line 2 of 5)
        let staff_middle_y = staff_vertical_offset + 4.0 * units_per_space;

        let mut stem_glyphs = Vec::new();

        // For each beam group, compute uniform stem direction and generate stems + beams
        for group in &beam_groups {
            if group.notes.len() < 2 {
                continue; // Skip degenerate groups (single note → use flag)
            }

            // T033: Compute uniform stem direction for the group using majority rule
            let group_direction = beams::compute_group_stem_direction(&group.notes, staff_middle_y);

            let notehead_width = stems::Stem::NOTEHEAD_WIDTH;

            // === PHASE 1: Compute initial stems and beam line ===
            // Create initial stems (may not reach the beam yet)
            // Adjust note Y for visual rendering: pitch_to_y subtracts 0.5 staff spaces
            // to compensate for dominant-baseline:middle in SVG text rendering. But stems
            // are SVG <line> elements (not text), so they need the visual center Y.
            let visual_y_offset = 0.5 * units_per_space;
            let mut initial_stems: Vec<stems::Stem> = Vec::new();
            for note in &group.notes {
                let visual_y = note.y + visual_y_offset;
                let mut stem =
                    stems::create_stem(note.x, visual_y, group_direction, notehead_width);

                // Enforce minimum stem length for beamed notes
                let stem_length = (stem.y_end - stem.y_start).abs();
                let min_length = stems::Stem::MIN_BEAMED_STEM_LENGTH;
                if stem_length < min_length {
                    match group_direction {
                        stems::StemDirection::Up => {
                            stem.y_end = stem.y_start - min_length;
                        }
                        stems::StemDirection::Down => {
                            stem.y_end = stem.y_start + min_length;
                        }
                    }
                }
                initial_stems.push(stem);
            }

            // Compute the beam line from first and last stem endpoints
            let first_stem_end = initial_stems[0].y_end;
            let last_stem_end = initial_stems.last().unwrap().y_end;
            let first_stem_x = initial_stems[0].x;
            let last_stem_x = initial_stems.last().unwrap().x;
            let dx = last_stem_x - first_stem_x;
            let beam_slope = if dx.abs() > 0.001 {
                (last_stem_end - first_stem_end) / dx
            } else {
                0.0
            };

            // Clamp beam slope
            let max_slope_units = beams::Beam::MAX_SLOPE * units_per_space;
            let max_slope_per_unit = if dx.abs() > 0.001 {
                max_slope_units / dx
            } else {
                0.0
            };
            let clamped_slope = beam_slope.clamp(-max_slope_per_unit, max_slope_per_unit);

            // Compute the beam Y at each stem's X position
            // Then find the "outermost" beam position that ensures ALL stems are long enough
            // For stem-up: beam is above (smaller Y), so we need the MINIMUM y_end
            // For stem-down: beam is below (larger Y), so we need the MAXIMUM y_end
            let mut beam_y_at_stems: Vec<f32> = Vec::new();
            for stem in &initial_stems {
                let beam_y = first_stem_end + clamped_slope * (stem.x - first_stem_x);
                beam_y_at_stems.push(beam_y);
            }

            // Check if any stem is too short to reach the beam line and adjust
            // The beam must be positioned so ALL stems can reach it
            let mut beam_offset = 0.0f32;
            for (i, stem) in initial_stems.iter().enumerate() {
                let beam_y = beam_y_at_stems[i];
                let min_length = stems::Stem::MIN_BEAMED_STEM_LENGTH;
                match group_direction {
                    stems::StemDirection::Up => {
                        // Stem goes up (negative Y). beam_y should be <= stem.y_start - min_length
                        let required_beam_y = stem.y_start - min_length;
                        if beam_y > required_beam_y {
                            // Beam needs to move further up (more negative)
                            let needed_offset = required_beam_y - beam_y;
                            beam_offset = beam_offset.min(needed_offset);
                        }
                    }
                    stems::StemDirection::Down => {
                        // Stem goes down (positive Y). beam_y should be >= stem.y_start + min_length
                        let required_beam_y = stem.y_start + min_length;
                        if beam_y < required_beam_y {
                            // Beam needs to move further down (more positive)
                            let needed_offset = required_beam_y - beam_y;
                            beam_offset = beam_offset.max(needed_offset);
                        }
                    }
                }
            }

            // === PHASE 2: Extend ALL stems to reach the beam line ===
            let mut stem_end_ys = Vec::new();
            let mut stem_xs = Vec::new();

            for (i, stem) in initial_stems.iter().enumerate() {
                let adjusted_beam_y = beam_y_at_stems[i] + beam_offset;
                // Extend stem to reach the beam
                let final_stem_end = adjusted_beam_y;

                // Create stem glyph with adjusted length
                let stem_top_y = stem.y_start.min(final_stem_end);
                let stem_height = (final_stem_end - stem.y_start).abs();

                let stem_glyph = Glyph {
                    codepoint: '\u{0000}'.to_string(),
                    position: Point {
                        x: stem.x,
                        y: stem_top_y,
                    },
                    bounding_box: BoundingBox {
                        x: stem.x - (stem.thickness / 2.0),
                        y: stem_top_y,
                        width: stem.thickness,
                        height: stem_height,
                    },
                    source_reference: SourceReference {
                        instrument_id: instrument_id.to_string(),
                        staff_index,
                        voice_index,
                        event_index: 0,
                    },
                };
                stem_glyphs.push(stem_glyph);
                stem_end_ys.push(final_stem_end);
                stem_xs.push(stem.x);
            }

            // === PHASE 3: Create beam at the adjusted position ===
            let beamable_with_stems: Vec<beams::BeamableNote> = group
                .notes
                .iter()
                .zip(stem_end_ys.iter().zip(stem_xs.iter()))
                .map(|(n, (&stem_end_y, &stem_x))| beams::BeamableNote {
                    x: stem_x,
                    y: n.y,
                    stem_end_y,
                    tick: n.tick,
                    duration_ticks: n.duration_ticks,
                    beam_levels: n.beam_levels,
                    beam_types: n.beam_types.clone(),
                })
                .collect();

            // Create beam — slope is already embedded in the stem_end_y values
            let slope = clamped_slope;
            if let Some(beam) = beams::create_beam(&beamable_with_stems, slope) {
                // Encode beam as special glyph (U+0001)
                // For sloped beam rendering, we encode:
                //   position.x/y = left-side beam start (x_start, y_start)
                //   bounding_box.x = x_start
                //   bounding_box.y = y_end (right-side Y for slope reconstruction)
                //   bounding_box.width = horizontal span (x_end - x_start)
                //   bounding_box.height = beam thickness
                let beam_glyph = Glyph {
                    codepoint: '\u{0001}'.to_string(),
                    position: Point {
                        x: beam.x_start,
                        y: beam.y_start,
                    },
                    bounding_box: BoundingBox {
                        x: beam.x_start,
                        y: beam.y_end, // Right-side Y for slope
                        width: beam.x_end - beam.x_start,
                        height: beam.thickness,
                    },
                    source_reference: SourceReference {
                        instrument_id: instrument_id.to_string(),
                        staff_index,
                        voice_index,
                        event_index: 0,
                    },
                };
                all_glyphs.push(beam_glyph);
            }

            // T027: Create secondary/tertiary beam levels for 16th, 32nd notes, etc.
            // Use beamable_with_stems (with correct stem_end_y) instead of original group
            let stem_direction_up = group_direction == stems::StemDirection::Up;
            let updated_group = beams::BeamGroup {
                notes: beamable_with_stems,
                beam_count: group.beam_count,
            };
            let multi_beams =
                beams::create_multi_level_beams(&updated_group, slope, stem_direction_up);
            for beam in multi_beams {
                let beam_glyph = Glyph {
                    codepoint: '\u{0001}'.to_string(),
                    position: Point {
                        x: beam.x_start,
                        y: beam.y_start,
                    },
                    bounding_box: BoundingBox {
                        x: beam.x_start,
                        y: beam.y_end, // Right-side Y for slope
                        width: beam.x_end - beam.x_start,
                        height: beam.thickness,
                    },
                    source_reference: SourceReference {
                        instrument_id: instrument_id.to_string(),
                        staff_index,
                        voice_index,
                        event_index: 0,
                    },
                };
                all_glyphs.push(beam_glyph);
            }
        }

        all_glyphs.extend(stem_glyphs);
    }

    all_glyphs
}

/// Create staff lines for a single staff
fn create_staff_lines(
    staff_index: usize,
    system_width: f32,
    units_per_space: f32,
    system_y_position: f32,
) -> [StaffLine; 5] {
    // Each staff is vertically offset based on its index, relative to system
    // Staff spacing: 20 staff spaces (400 logical units at default scale of 20)
    let staff_vertical_offset = system_y_position + (staff_index as f32 * 20.0 * units_per_space);

    // Create 5 evenly spaced lines (2 staff spaces apart = 20 logical units)
    let mut lines = Vec::new();
    for line_index in 0..5 {
        let y_position = staff_vertical_offset + (line_index as f32 * 2.0 * units_per_space);
        lines.push(StaffLine {
            y_position,
            start_x: 0.0,
            end_x: system_width,
        });
    }

    // Convert Vec to array (guaranteed to have exactly 5 elements)
    lines.try_into().unwrap()
}

/// Create bar lines for a single staff at measure boundaries
///
/// # Arguments
/// * `measure_infos` - All measures with their tick ranges and widths
/// * `tick_range` - The system's tick range
/// * `staff_index` - Index of staff for vertical positioning
/// * `left_margin` - Left margin where music content starts
/// * `system_width` - Total width of the system
/// * `units_per_space` - Scaling factor
/// * `system_y_position` - Vertical position of the system
///
/// # Returns
/// Vector of bar lines positioned at measure boundaries
#[allow(clippy::too_many_arguments)]
fn create_bar_lines(
    measure_infos: &[breaker::MeasureInfo],
    tick_range: &TickRange,
    staff_index: usize,
    left_margin: f32,
    _system_width: f32,
    units_per_space: f32,
    system_y_position: f32,
    note_positions: &HashMap<u32, f32>,
) -> Vec<BarLine> {
    let mut bar_lines = Vec::new();

    // Calculate staff vertical offset relative to system
    let staff_vertical_offset = system_y_position + (staff_index as f32 * 20.0 * units_per_space);

    // Y positions for top and bottom staff lines
    let y_start = staff_vertical_offset; // Top line (line 0)
    let y_end = staff_vertical_offset + (4.0 * 2.0 * units_per_space); // Bottom line (line 4)

    // Find measures that overlap with this system's tick range
    let measures_in_system: Vec<&breaker::MeasureInfo> = measure_infos
        .iter()
        .filter(|m| m.start_tick < tick_range.end_tick && m.end_tick > tick_range.start_tick)
        .collect();

    if measures_in_system.is_empty() {
        return bar_lines;
    }

    // Add bar lines at the end of each measure using note positions
    // This ensures barlines use the same scaling as notes
    for measure in measures_in_system.iter() {
        // Skip barline if measure extends beyond system
        if measure.end_tick > tick_range.end_tick {
            continue;
        }

        // Find the x-position for the barline by looking for the last note IN this measure
        // Notes at end_tick belong to NEXT measure (tick range is exclusive end)
        let barline_x = note_positions
            .iter()
            .filter(|(tick, _)| **tick >= measure.start_tick && **tick < measure.end_tick)
            .max_by_key(|(tick, _)| *tick)
            .map(|(_, x)| *x + 30.0) // Add clearance for notehead width + spacing
            .unwrap_or_else(|| {
                // No notes in this measure, use left_margin as fallback
                left_margin + 30.0
            });

        // Determine bar line type
        let bar_type = if measure.end_tick == tick_range.end_tick {
            // Check if this is the very last measure in the entire score
            let is_last_measure =
                measure_infos.last().map(|m| m.end_tick) == Some(measure.end_tick);
            if is_last_measure {
                BarLineType::Final
            } else {
                BarLineType::Single
            }
        } else {
            BarLineType::Single
        };

        // Create bar line segments with explicit geometry (Principle VI: Layout Engine Authority)
        let segments = create_bar_line_segments(barline_x, y_start, y_end, &bar_type);

        bar_lines.push(BarLine { segments, bar_type });
    }

    bar_lines
}

/// Creates bar line segments with explicit geometry for each line
/// This ensures the renderer doesn't calculate positions (Principle VI compliance)
fn create_bar_line_segments(
    x_position: f32,
    y_start: f32,
    y_end: f32,
    bar_type: &BarLineType,
) -> Vec<BarLineSegment> {
    const THIN_WIDTH: f32 = 1.5;
    const THICK_WIDTH: f32 = 4.0;
    const DOUBLE_SPACING: f32 = 4.0; // Space between double bar lines
    const FINAL_SPACING: f32 = 4.0; // Space between thin and thick in final bar

    match bar_type {
        BarLineType::Single => {
            vec![BarLineSegment {
                x_position,
                y_start,
                y_end,
                stroke_width: THIN_WIDTH,
            }]
        }
        BarLineType::Double => {
            vec![
                BarLineSegment {
                    x_position: x_position - DOUBLE_SPACING / 2.0,
                    y_start,
                    y_end,
                    stroke_width: THIN_WIDTH,
                },
                BarLineSegment {
                    x_position: x_position + DOUBLE_SPACING / 2.0,
                    y_start,
                    y_end,
                    stroke_width: THIN_WIDTH,
                },
            ]
        }
        BarLineType::Final => {
            vec![
                BarLineSegment {
                    x_position: x_position - FINAL_SPACING - THICK_WIDTH / 2.0,
                    y_start,
                    y_end,
                    stroke_width: THIN_WIDTH,
                },
                BarLineSegment {
                    x_position: x_position + THICK_WIDTH / 2.0,
                    y_start,
                    y_end,
                    stroke_width: THICK_WIDTH,
                },
            ]
        }
    }
}

/// Creates bracket/brace glyph with calculated geometry for multi-staff groups
fn create_bracket_glyph(
    staves: &[Staff],
    bracket_type: &BracketType,
    _config: &LayoutConfig,
) -> BracketGlyph {
    let first_staff = &staves[0];
    let last_staff = &staves[staves.len() - 1];

    // Calculate gap center between first staff bottom and last staff top
    let first_staff_bottom = first_staff.staff_lines[4].y_position;
    let last_staff_top = last_staff.staff_lines[0].y_position;
    let gap_center = (first_staff_bottom + last_staff_top) / 2.0;

    // Brace parameters (fine-tuned for visual centering)
    let extension = 280.0; // Distance from gap center to top/bottom of brace
    let center_y = gap_center + 54.0; // Offset to account for SMuFL glyph baseline
    let height = extension * 2.0;
    const BRACE_NATURAL_HEIGHT: f32 = 320.0; // SMuFL brace U+E000 at fontSize 80
    let scale_y = height / BRACE_NATURAL_HEIGHT;

    let codepoint = match bracket_type {
        BracketType::Brace => "\u{E000}".to_string(),
        BracketType::Bracket => "\u{E002}".to_string(),
        BracketType::None => String::new(),
    };

    let x_position = 15.0; // Left margin
    let top_y = gap_center - extension;
    let _bottom_y = gap_center + extension;

    BracketGlyph {
        codepoint,
        x: x_position,
        y: center_y,
        scale_y,
        bounding_box: BoundingBox {
            x: x_position - 5.0,
            y: top_y,
            width: 20.0,
            height,
        },
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// T011: Unit test for create_staff_lines() verifying 5 lines with 20-unit spacing
    #[test]
    fn test_create_staff_lines_spacing() {
        let units_per_space = 20.0;
        let system_width = 1200.0;
        let staff_index = 0;

        let lines = create_staff_lines(staff_index, system_width, units_per_space, 0.0);

        // Verify exactly 5 lines
        assert_eq!(lines.len(), 5, "Should have exactly 5 staff lines");

        // Verify y-positions with 40-unit spacing (2 * units_per_space)
        assert_eq!(lines[0].y_position, 0.0, "Line 0 should be at y=0");
        assert_eq!(lines[1].y_position, 40.0, "Line 1 should be at y=40");
        assert_eq!(lines[2].y_position, 80.0, "Line 2 should be at y=80");
        assert_eq!(lines[3].y_position, 120.0, "Line 3 should be at y=120");
        assert_eq!(lines[4].y_position, 160.0, "Line 4 should be at y=160");

        // Verify all lines span full system width
        for (i, line) in lines.iter().enumerate() {
            assert_eq!(line.start_x, 0.0, "Line {} should start at x=0", i);
            assert_eq!(
                line.end_x, system_width,
                "Line {} should end at system_width",
                i
            );
        }
    }

    /// T011: Unit test for multi-staff layout with correct vertical offsetting
    #[test]
    fn test_create_staff_lines_multi_staff() {
        let units_per_space = 20.0;
        let system_width = 1200.0;

        // First staff (staff_index = 0) in system at y=0
        let staff_0 = create_staff_lines(0, system_width, units_per_space, 0.0);
        assert_eq!(staff_0[0].y_position, 0.0);
        assert_eq!(staff_0[4].y_position, 160.0);

        // Second staff (staff_index = 1) - should be offset by 20 staff spaces (400 units)
        let staff_1 = create_staff_lines(1, system_width, units_per_space, 0.0);
        let expected_offset = 20.0 * units_per_space; // 400 units
        assert_eq!(staff_1[0].y_position, expected_offset);
        assert_eq!(staff_1[4].y_position, expected_offset + 160.0);
    }

    /// T011: Unit test for different units_per_space values
    #[test]
    fn test_create_staff_lines_scale_independence() {
        let system_width = 1200.0;
        let staff_index = 0;

        // Test with different scale (units_per_space = 10)
        let lines_scale_10 = create_staff_lines(staff_index, system_width, 10.0, 0.0);
        assert_eq!(lines_scale_10[0].y_position, 0.0);
        assert_eq!(lines_scale_10[1].y_position, 20.0); // 2 * 10
        assert_eq!(lines_scale_10[4].y_position, 80.0); // 4 * 2 * 10

        // Test with different scale (units_per_space = 25)
        let lines_scale_25 = create_staff_lines(staff_index, system_width, 25.0, 0.0);
        assert_eq!(lines_scale_25[0].y_position, 0.0);
        assert_eq!(lines_scale_25[1].y_position, 50.0); // 2 * 25
        assert_eq!(lines_scale_25[4].y_position, 200.0); // 4 * 2 * 25
    }

    /// T029: Integration test for structural glyph generation
    #[test]
    fn test_structural_glyphs_populated() {
        // Create a minimal score with clef, time sig, and key sig
        let score = serde_json::json!({
            "instruments": [{
                "id": "violin",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 1 },  // G major (1 sharp)
                    "voices": [{
                        "notes": [
                            { "pitch": 60, "tick": 0, "duration": 960 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        // Verify at least one system was created
        assert!(
            !layout.systems.is_empty(),
            "Should have at least one system"
        );
        let system = &layout.systems[0];

        // Verify at least one staff group exists
        assert!(
            !system.staff_groups.is_empty(),
            "Should have at least one staff group"
        );
        let staff_group = &system.staff_groups[0];

        // Verify at least one staff exists
        assert!(
            !staff_group.staves.is_empty(),
            "Should have at least one staff"
        );
        let staff = &staff_group.staves[0];

        // Verify structural glyphs are populated
        assert!(
            !staff.structural_glyphs.is_empty(),
            "structural_glyphs should be populated with clef, time sig, and key sig"
        );

        // Should have at least:
        // - 1 clef
        // - 2 time signature digits (numerator + denominator)
        // - 1 key signature accidental (G major = 1 sharp)
        // Total: >= 4 glyphs
        assert!(
            staff.structural_glyphs.len() >= 4,
            "Expected at least 4 structural glyphs (clef + 2 time sig digits + 1 key sig accidental), got {}",
            staff.structural_glyphs.len()
        );

        // Verify first glyph is a clef (starts with 'E' in SMuFL codepoint range)
        let first_glyph = &staff.structural_glyphs[0];
        // Extract first Unicode scalar value from codepoint string
        if let Some(first_char) = first_glyph.codepoint.chars().next() {
            let clef_codepoint = first_char as u32;
            assert!(
                (0xE050..=0xE07F).contains(&clef_codepoint),
                "First glyph should be a clef (U+E050-U+E07F), got U+{:04X}",
                clef_codepoint
            );
        } else {
            panic!("Glyph codepoint is empty");
        }
    }

    /// T063: Integration test for piano layout verifying 2 staves with correct vertical spacing
    #[test]
    fn test_piano_multi_staff_layout() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [
                    {
                        "clef": "Treble",
                        "time_signature": { "numerator": 4, "denominator": 4 },
                        "key_signature": { "sharps": 0 },
                        "voices": [{
                            "notes": [
                                { "pitch": 72, "tick": 0, "duration": 960 }
                            ]
                        }]
                    },
                    {
                        "clef": "Bass",
                        "time_signature": { "numerator": 4, "denominator": 4 },
                        "key_signature": { "sharps": 0 },
                        "voices": [{
                            "notes": [
                                { "pitch": 48, "tick": 0, "duration": 960 }
                            ]
                        }]
                    }
                ]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        // Verify system exists
        assert!(
            !layout.systems.is_empty(),
            "Should have at least one system"
        );
        let system = &layout.systems[0];

        // Verify staff group exists
        assert!(
            !system.staff_groups.is_empty(),
            "Should have at least one staff group"
        );
        let staff_group = &system.staff_groups[0];

        // Verify 2 staves exist (treble + bass)
        assert_eq!(staff_group.staves.len(), 2, "Piano should have 2 staves");

        // Verify vertical spacing between staves
        let treble_staff = &staff_group.staves[0];
        let bass_staff = &staff_group.staves[1];

        let treble_top = treble_staff.staff_lines[0].y_position;
        let bass_top = bass_staff.staff_lines[0].y_position;

        // Vertical spacing should be 20 staff spaces (400 units at default units_per_space=20)
        let expected_spacing = 20.0 * config.units_per_space; // 400 units
        assert_eq!(
            bass_top - treble_top,
            expected_spacing,
            "Staff vertical spacing should be 20 staff spaces (400 units)"
        );

        // Verify bracket type is Brace for piano
        assert_eq!(
            staff_group.bracket_type,
            BracketType::Brace,
            "Piano should have Brace bracket type"
        );

        // Verify bracket glyph exists
        assert!(
            staff_group.bracket_glyph.is_some(),
            "Piano staff group should have bracket glyph"
        );
    }

    /// T064: Unit test for brace/bracket positioning and vertical scaling
    #[test]
    fn test_create_bracket_glyph_brace() {
        let config = LayoutConfig::default();

        // Create two dummy staves at different vertical positions
        let staff_0_lines = create_staff_lines(0, 1200.0, config.units_per_space, 0.0);
        let staff_1_lines = create_staff_lines(1, 1200.0, config.units_per_space, 0.0);

        let staff_0 = Staff {
            staff_lines: staff_0_lines,
            glyph_runs: vec![],
            structural_glyphs: vec![],
            bar_lines: vec![],
            ledger_lines: vec![],
        };

        let staff_1 = Staff {
            staff_lines: staff_1_lines,
            glyph_runs: vec![],
            structural_glyphs: vec![],
            bar_lines: vec![],
            ledger_lines: vec![],
        };

        let staves = vec![staff_0, staff_1];
        let bracket_type = BracketType::Brace;

        let bracket_glyph = create_bracket_glyph(&staves, &bracket_type, &config);

        // Verify brace codepoint
        assert_eq!(
            bracket_glyph.codepoint, "\u{E000}",
            "Brace should use SMuFL codepoint U+E000"
        );

        // Verify x position (left margin)
        assert_eq!(bracket_glyph.x, 15.0, "Brace should be at x=15");

        // Verify vertical scaling is applied
        assert!(
            bracket_glyph.scale_y > 0.0,
            "Brace should have positive vertical scale"
        );

        // Verify bounding box spans both staves
        let first_staff_top = staves[0].staff_lines[0].y_position;
        let last_staff_bottom = staves[1].staff_lines[4].y_position;

        // Brace should extend to cover both staves
        assert!(
            bracket_glyph.bounding_box.y <= first_staff_top,
            "Brace bounding box should start at or above first staff"
        );
        assert!(
            bracket_glyph.bounding_box.y + bracket_glyph.bounding_box.height >= last_staff_bottom,
            "Brace bounding box should extend to or below last staff"
        );
    }

    /// T064: Unit test for square bracket positioning (ensemble scores)
    #[test]
    fn test_create_bracket_glyph_bracket() {
        let config = LayoutConfig::default();

        let staff_0_lines = create_staff_lines(0, 1200.0, config.units_per_space, 0.0);
        let staff_1_lines = create_staff_lines(1, 1200.0, config.units_per_space, 0.0);

        let staff_0 = Staff {
            staff_lines: staff_0_lines,
            glyph_runs: vec![],
            structural_glyphs: vec![],
            bar_lines: vec![],
            ledger_lines: vec![],
        };

        let staff_1 = Staff {
            staff_lines: staff_1_lines,
            glyph_runs: vec![],
            structural_glyphs: vec![],
            bar_lines: vec![],
            ledger_lines: vec![],
        };

        let staves = vec![staff_0, staff_1];
        let bracket_type = BracketType::Bracket;

        let bracket_glyph = create_bracket_glyph(&staves, &bracket_type, &config);

        // Verify bracket codepoint
        assert_eq!(
            bracket_glyph.codepoint, "\u{E002}",
            "Bracket should use SMuFL codepoint U+E002"
        );
    }

    /// T074: Test notes on both staves render correctly relative to their respective staff lines
    #[test]
    fn test_notes_on_multi_staff() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [
                    {
                        "clef": "Treble",
                        "time_signature": { "numerator": 4, "denominator": 4 },
                        "key_signature": { "sharps": 0 },
                        "voices": [{
                            "notes": [
                                { "pitch": 72, "tick": 0, "duration": 960 }
                            ]
                        }]
                    },
                    {
                        "clef": "Bass",
                        "time_signature": { "numerator": 4, "denominator": 4 },
                        "key_signature": { "sharps": 0 },
                        "voices": [{
                            "notes": [
                                { "pitch": 48, "tick": 0, "duration": 960 }
                            ]
                        }]
                    }
                ]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let system = &layout.systems[0];
        let staff_group = &system.staff_groups[0];

        // Both staves should have glyph runs (noteheads)
        assert!(
            !staff_group.staves[0].glyph_runs.is_empty(),
            "Treble staff should have glyphs"
        );
        assert!(
            !staff_group.staves[1].glyph_runs.is_empty(),
            "Bass staff should have glyphs"
        );

        // Verify treble staff note is positioned relative to treble staff lines
        let treble_line_0 = staff_group.staves[0].staff_lines[0].y_position;
        let treble_glyph = &staff_group.staves[0].glyph_runs[0].glyphs[0];
        assert!(
            treble_glyph.position.y >= treble_line_0 - 100.0,
            "Treble note should be near treble staff"
        );

        // Verify bass staff note is positioned relative to bass staff lines
        let bass_line_0 = staff_group.staves[1].staff_lines[0].y_position;
        let bass_glyph = &staff_group.staves[1].glyph_runs[0].glyphs[0];
        assert!(
            bass_glyph.position.y >= bass_line_0 - 100.0,
            "Bass note should be near bass staff"
        );

        // Verify bass staff is below treble staff
        assert!(
            bass_line_0 > treble_line_0,
            "Bass staff should be below treble staff"
        );
    }

    /// T020: Integration test — 4 eighth notes with beam info produce correct glyphs
    #[test]
    fn test_four_beamed_eighths_produce_noteheads_stems_beam() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Begin"}] },
                            { "pitch": 74, "tick": 480, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Continue"}] },
                            { "pitch": 76, "tick": 960, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Continue"}] },
                            { "pitch": 77, "tick": 1440, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "End"}] }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        // Collect all glyphs across all runs
        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        // Count glyph types
        let noteheads = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .count();
        let stems = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0000}")
            .count();
        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();
        let combined_eighth = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E1D7}")
            .count();

        assert_eq!(
            noteheads, 4,
            "Should have 4 bare noteheadBlack glyphs (U+E0A4)"
        );
        assert_eq!(stems, 4, "Should have 4 stem glyphs (U+0000)");
        assert_eq!(beams, 1, "Should have 1 beam glyph (U+0001)");
        assert_eq!(
            combined_eighth, 0,
            "Should have 0 combined eighth note glyphs (U+E1D7)"
        );
    }

    /// T021: Integration test — mixed quarters and eighths produce correct glyphs
    #[test]
    fn test_mixed_quarters_and_beamed_eighths() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 960 },
                            { "pitch": 74, "tick": 960, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Begin"}] },
                            { "pitch": 76, "tick": 1440, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "End"}] },
                            { "pitch": 77, "tick": 1920, "duration": 960 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        // Count glyph types
        let combined_quarter = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E1D5}")
            .count();
        let bare_noteheads = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .count();
        let stems = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0000}")
            .count();
        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();
        let combined_eighth = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E1D7}")
            .count();

        assert_eq!(
            combined_quarter, 2,
            "Should have 2 combined quarter note glyphs (U+E1D5)"
        );
        assert_eq!(
            bare_noteheads, 2,
            "Should have 2 bare noteheadBlack for beamed eighths"
        );
        assert_eq!(stems, 2, "Should have 2 stem glyphs for beamed eighths");
        assert_eq!(
            beams, 1,
            "Should have 1 beam glyph connecting the 2 eighths"
        );
        assert_eq!(combined_eighth, 0, "Should have 0 combined eighth glyphs");
    }

    /// T028: Integration test — 4 sixteenth notes produce 2 beam levels
    #[test]
    fn test_four_sixteenths_two_beam_levels() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "Begin"}, {"number": 2, "beam_type": "Begin"}] },
                            { "pitch": 74, "tick": 240, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "Continue"}, {"number": 2, "beam_type": "Continue"}] },
                            { "pitch": 76, "tick": 480, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "Continue"}, {"number": 2, "beam_type": "Continue"}] },
                            { "pitch": 77, "tick": 720, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "End"}, {"number": 2, "beam_type": "End"}] }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();

        assert_eq!(
            beams, 2,
            "4 sixteenth notes should produce 2 beam glyphs (level 1 + level 2)"
        );
    }

    /// T029: Integration test — mixed eighths + sixteenths produce correct beaming
    #[test]
    fn test_mixed_eighths_sixteenths_multi_level() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Begin"}] },
                            { "pitch": 74, "tick": 480, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "Continue"}, {"number": 2, "beam_type": "Begin"}] },
                            { "pitch": 76, "tick": 720, "duration": 240,
                              "beams": [{"number": 1, "beam_type": "End"}, {"number": 2, "beam_type": "End"}] }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();
        let noteheads = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .count();

        assert_eq!(noteheads, 3, "Should have 3 bare noteheads (all beamed)");
        assert_eq!(
            beams, 2,
            "Should have 2 beams (level 1 spans all, level 2 spans sixteenths)"
        );
    }

    /// T036: High-pitched beamed group → stems down, beam below noteheads
    #[test]
    fn test_stem_direction_high_notes_stems_down() {
        // All notes above middle line (high pitches like C6, D6, E6, F6)
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 84, "tick": 0, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Begin"}] },
                            { "pitch": 86, "tick": 480, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "End"}] }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        // Find stem glyphs
        let stem_glyphs: Vec<_> = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0000}")
            .collect();

        assert_eq!(stem_glyphs.len(), 2, "Should have 2 stems");

        // For high notes, stems should point down (y_end > y_start in screen coordinates)
        // Find the noteheads to compare positions
        let notehead_glyphs: Vec<_> = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .collect();

        assert_eq!(notehead_glyphs.len(), 2, "Should have 2 noteheads");

        // Stem bounding box y + height should extend below the notehead y
        // (stems down = extending downward from notehead)
        for stem in &stem_glyphs {
            let stem_bottom = stem.bounding_box.y + stem.bounding_box.height;
            assert!(
                stem_bottom > stem.position.y,
                "Stem should extend downward (stem_bottom {} > position.y {})",
                stem_bottom,
                stem.position.y
            );
        }
    }

    /// T037: Beamed group spanning both sides → uniform direction
    #[test]
    fn test_uniform_stem_direction_mixed_positions() {
        // Mix of notes: 2 above middle, 1 below → majority above → stems down
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 48, "tick": 0, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Begin"}] },
                            { "pitch": 48, "tick": 480, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "Continue"}] },
                            { "pitch": 84, "tick": 960, "duration": 480,
                              "beams": [{"number": 1, "beam_type": "End"}] }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let stem_glyphs: Vec<_> = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0000}")
            .collect();

        assert_eq!(stem_glyphs.len(), 3, "Should have 3 stems");

        // All stems should have a consistent direction (same sign of displacement)
        // Collect stem displacement directions (positive = down, negative = up)
        let displacements: Vec<f32> = stem_glyphs.iter().map(|s| s.bounding_box.height).collect();

        // All stems should be non-zero height
        for d in &displacements {
            assert!(*d > 0.0, "Stem height should be positive: {}", d);
        }
    }

    /// T046: Algorithmic beaming for 4/4 without <beam> elements
    #[test]
    fn test_algorithmic_beaming_4_4() {
        // No beam_info → algorithmic fallback groups by beat
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480 },
                            { "pitch": 74, "tick": 480, "duration": 480 },
                            { "pitch": 76, "tick": 960, "duration": 480 },
                            { "pitch": 77, "tick": 1440, "duration": 480 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();
        let noteheads = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .count();

        assert_eq!(noteheads, 4, "All 4 eighths should use bare noteheadBlack");
        assert_eq!(
            beams, 2,
            "Algorithmic beaming in 4/4 should produce 2 beam groups (2 per beat)"
        );
    }

    /// T047: Single isolated eighth note uses combined flag glyph
    #[test]
    fn test_single_eighth_uses_flag() {
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480 },
                            { "pitch": 74, "tick": 960, "duration": 960 },
                            { "pitch": 76, "tick": 1920, "duration": 960 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let combined_eighth = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E1D7}")
            .count();
        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();

        // Single eighth note can't form a beam group, so it should use the combined flag glyph
        assert_eq!(
            combined_eighth, 1,
            "Single eighth should use combined flag glyph U+E1D7"
        );
        assert_eq!(beams, 0, "No beams for single eighth note");
    }

    /// T051: Degenerate single-note beam group falls back to flagged rendering
    #[test]
    fn test_degenerate_single_note_group_uses_flag() {
        // A single eighth note at beat boundary with no partner → no beam, uses flag
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480 },
                            { "pitch": 74, "tick": 480, "duration": 960 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let combined_eighth = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E1D7}")
            .count();
        let bare_noteheads = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{E0A4}")
            .count();
        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();

        assert_eq!(
            combined_eighth, 1,
            "Single eighth should use combined flag glyph"
        );
        assert_eq!(
            bare_noteheads, 0,
            "No bare noteheads when no beam group forms"
        );
        assert_eq!(beams, 0, "No beams for degenerate single-note group");
    }

    /// T052: Beams do not cross bar lines
    #[test]
    fn test_beams_do_not_cross_barlines() {
        // 2 eighths at end of measure 1 + 2 eighths at start of measure 2
        // Should produce 2 separate beam groups, not 1 spanning the barline
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 2880, "duration": 480 },
                            { "pitch": 74, "tick": 3360, "duration": 480 },
                            { "pitch": 76, "tick": 3840, "duration": 480 },
                            { "pitch": 77, "tick": 4320, "duration": 480 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();

        assert_eq!(
            beams, 2,
            "Should produce 2 separate beams (one per measure, not crossing barline)"
        );
    }

    /// T053: Beams break at rests
    #[test]
    fn test_beams_break_at_rests() {
        // 2 eighths, then a quarter rest, then 2 more eighths → 2 beam groups
        let score = serde_json::json!({
            "instruments": [{
                "id": "piano",
                "staves": [{
                    "clef": "Treble",
                    "time_signature": { "numerator": 4, "denominator": 4 },
                    "key_signature": { "sharps": 0 },
                    "voices": [{
                        "notes": [
                            { "pitch": 72, "tick": 0, "duration": 480 },
                            { "pitch": 74, "tick": 480, "duration": 480 },
                            { "pitch": 76, "tick": 1920, "duration": 480 },
                            { "pitch": 77, "tick": 2400, "duration": 480 }
                        ]
                    }]
                }]
            }]
        });

        let config = LayoutConfig::default();
        let layout = compute_layout(&score, &config);

        let staff = &layout.systems[0].staff_groups[0].staves[0];
        let all_glyphs: Vec<_> = staff
            .glyph_runs
            .iter()
            .flat_map(|run| run.glyphs.iter())
            .collect();

        let beams = all_glyphs
            .iter()
            .filter(|g| g.codepoint == "\u{0001}")
            .count();

        assert_eq!(
            beams, 2,
            "Should produce 2 beams (broken by rest gap between beats)"
        );
    }
}
