# Implementation Plan: Staff Notation Visualization

**Branch**: `002-staff-notation-view` | **Date**: 2024-02-06 | **Spec**: [spec.md](./spec.md)  
**Input**: Feature specification from `/specs/002-staff-notation-view/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

**Primary Requirement**: Create a visual representation of notes using traditional staff notation (five-line staff with treble/bass clef) to enable musicians to read and interact with score data in a familiar format.

**Technical Approach** (from research):

1. **SMuFL Bravura Font**: Use industry-standard music font via `@font-face` with WOFF2 format (~50KB subset) for all musical symbols (clefs, note heads, accidentals)

2. **Three-Layer Architecture**:
   - **MusicTimeline** (container): Fetches Score from API, extracts Voice data
   - **NotationLayoutEngine** (pure service): Calculates geometry (note positions, ledger lines, barlines) with no React/DOM dependencies
   - **NotationRenderer** (presentational): Renders SVG elements from geometry, handles interaction events

3. **Positioning Algorithms**:
   - Staff-space coordinate system (10px fundamental unit)
   - MIDI pitch → staff position → Y-coordinate mapping with clef awareness
   - Proportional horizontal spacing (0.1 px/tick) with 15px minimum note spacing

4. **Performance Strategy**:
   - Virtual scrolling/windowing: Only render notes in viewport + 200px buffer
   - Memoization: Cache layout calculations with React `useMemo`
   - SVG rendering: Efficient for 1000-5000 elements, GPU-accelerated CSS transforms

**Scope**: Frontend-only feature, no backend changes. Uses existing GET `/scores/{id}` API. MVP focuses on single-voice display with fixed clef and basic note heads (no stems, beams, accidentals).

## Technical Context

**Language/Version**: TypeScript 5.0+, React 18+  
**Primary Dependencies**: React, TypeScript, Bravura font (SMuFL), existing Score API client  
**Storage**: N/A (frontend-only feature, reads from existing backend API)  
**Testing**: Jest + React Testing Library for components, pure function tests for layout engine  
**Target Platform**: Web browsers (Chrome 90+, Firefox 88+, Safari 14+)  
**Project Type**: web (monorepo with `backend/` and `frontend/` directories)  
**Performance Goals**: 
  - <500ms initial render of 100 notes (SC-002)
  - <50ms interaction response for note selection (SC-004)
  - 60fps scrolling with 1000 measures (SC-005)
  - <1px vertical positioning accuracy (SC-003)
**Constraints**: 
  - <200KB total bundle size increase (frontend constraint)
  - Synchronous layout calculation (no web workers for MVP)
  - Single-voice display only (multi-voice deferred to P5)
  - No rhythmic notation (stems/beams) in MVP (P2-P3)
**Scale/Scope**: 
  - Support scores with 1000 measures (~384,000 ticks at 4/4 time)
  - Handle 5000+ notes with virtual scrolling
  - Single staff system (5 lines) per viewport

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Domain-Driven Design
**Status**: ✅ **PASS**

- **Assessment**: Feature consumes existing domain model (Score, Voice, Note, StructuralEvent) without modification. No new aggregates or entities introduced. Frontend visualization layer does not alter backend domain logic.
- **Ubiquitous Language**: Uses existing terms (Note, Voice, Timeline, Tick, MIDI pitch) with addition of music notation terms (staff, clef, ledger line) which are well-defined in music theory.
- **Justification**: Frontend-only feature naturally separates presentation concerns from domain model.

### II. Hexagonal Architecture
**Status**: ✅ **PASS**

- **Assessment**: 
  - **Port**: Frontend consumes existing ScoreApiClient (HTTP adapter to backend)
  - **No Backend Changes**: Backend domain core remains untouched
  - **Dependency Flow**: Frontend → API Client → Backend (all dependencies point inward)
  - **Pure Layout Service**: NotationLayoutEngine has zero external dependencies, fully testable in isolation
- **Justification**: Frontend is an adapter consuming the API port. No architectural boundaries violated.

### III. API-First Development
**Status**: ✅ **PASS**

- **Assessment**: 
  - Uses existing GET `/scores/{id}` endpoint
  - No new API contracts required (confirmed: no `contracts/` directory needed)
  - Backend exposes data, frontend consumes for visualization
  - Contract tests already exist for Score API (from 001-score-model)
- **Justification**: Frontend-only feature leverages existing API contract without modification.

### IV. Precision & Fidelity
**Status**: ✅ **PASS**

- **Assessment**:
  - Respects 960 PPQ from backend (immutable)
  - Uses `start_tick` integer values directly (no floating-point conversion for timing)
  - Horizontal spacing (`pixelsPerTick = 0.1`) is rendering-only, does not affect domain model
  - MIDI pitch values (integers) mapped directly to staff positions
- **Justification**: Visualization layer preserves backend precision. Pixel positions are presentation concerns, do not corrupt domain data.

### V. Test-First Development
**Status**: ⚠️ **DEFERRED TO IMPLEMENTATION**

- **Assessment**: 
  - Layout engine designed as pure functions (deterministic, easily testable)
  - Component architecture separates testable units (layout service, renderer, coordinator)
  - Test strategy documented in data-model.md (unit tests for algorithms, integration tests for rendering)
- **Action Required**: During implementation phase (/speckit.tasks), write tests *before* code (red-green-refactor)
- **Non-negotiable**: No code commits without corresponding tests

---

**Constitution Check Summary**: ✅ **ALL GATES PASSED**  
No violations, no complexity tracking needed. Feature aligns with all 5 core principles.


## Project Structure

### Documentation (this feature)

```text
specs/002-staff-notation-view/
├── plan.md              # This file (/speckit.plan command output) - COMPLETE
├── research.md          # Phase 0 output (/speckit.plan command) - COMPLETE
├── data-model.md        # Phase 1 output (/speckit.plan command) - COMPLETE
├── quickstart.md        # Phase 1 output (/speckit.plan command) - COMPLETE
├── contracts/           # NOT NEEDED (uses existing API)
├── checklists/
│   └── requirements.md  # Validation checklist - COMPLETE
└── spec.md              # Feature specification - COMPLETE

* tasks.md will be created by /speckit.tasks command (separate phase)
```

### Source Code (repository root)

```text
frontend/
├── src/
│   ├── components/
│   │   ├── notation/                    # NEW: Staff notation components
│   │   │   ├── StaffNotation.tsx        # Coordinator: layout + state
│   │   │   ├── NotationRenderer.tsx     # Presentational: SVG rendering
│   │   │   └── index.ts                 # Barrel export
│   │   ├── MusicTimeline.tsx            # MODIFIED: Add StaffNotation integration
│   │   ├── InstrumentList.tsx           # Existing (unchanged)
│   │   └── NoteDisplay.tsx              # Existing (unchanged)
│   ├── services/
│   │   ├── notation/                    # NEW: Layout calculation service
│   │   │   ├── NotationLayoutEngine.ts  # Pure functions: geometry calculation
│   │   │   └── index.ts                 # Barrel export
│   │   └── api/
│   │       └── ScoreApiClient.ts        # Existing (unchanged)
│   ├── types/
│   │   ├── notation/                    # NEW: Notation-specific types
│   │   │   ├── layout.ts                # LayoutGeometry, NotePosition, etc.
│   │   │   ├── config.ts                # StaffConfig, defaults
│   │   │   └── index.ts                 # Barrel export
│   │   └── score.ts                     # Existing (unchanged)
│   └── index.css                        # MODIFIED: Add Bravura font @font-face
├── public/
│   └── fonts/
│       └── Bravura.woff2                # NEW: SMuFL music font (~50KB)
└── tests/
    ├── components/
    │   └── notation/                    # NEW: Component tests
    │       ├── StaffNotation.test.tsx
    │       └── NotationRenderer.test.tsx
    └── services/
        └── notation/                    # NEW: Layout engine tests
            └── NotationLayoutEngine.test.ts

backend/
└── (no changes - frontend-only feature)
```

**Structure Decision**: 

This is a **web application** (monorepo with `frontend/` and `backend/` directories). The feature is **frontend-only**, adding new directories under `frontend/src/`:

1. **`components/notation/`**: React components for staff rendering
   - `StaffNotation.tsx`: Manages viewport state, calculates layout with memoization
   - `NotationRenderer.tsx`: Pure presentational component, renders SVG from geometry

2. **`services/notation/`**: Pure TypeScript layout calculation service
   - `NotationLayoutEngine.ts`: All geometry algorithms (pitch positioning, spacing, ledger lines, barlines)
   - Zero React/DOM dependencies for maximum testability

3. **`types/notation/`**: TypeScript interfaces for notation domain
   - `layout.ts`: Geometry types (NotePosition, LayoutGeometry, etc.)
   - `config.ts`: Configuration and defaults (StaffConfig, DEFAULT_STAFF_CONFIG)

4. **`public/fonts/`**: Static asset for Bravura music font
   - Loaded via `@font-face` in `index.css`

**Integration Point**: Existing `MusicTimeline.tsx` component will be modified to render `<StaffNotation>` component, passing voice data as props.

**No Backend Changes**: Feature consumes existing GET `/scores/{id}` API endpoint. No new routes, no domain model changes.

## Complexity Tracking

**Status**: ✅ **NO VIOLATIONS**

No entries in this table. All Constitution checks passed without exceptions.

---

## Phase 0: Research (COMPLETE)

**Output**: `research.md` (327 lines)

**Decisions Made**:
1. **Q1: SMuFL Font Integration** → Use Bravura WOFF2 via @font-face (~50KB)
2. **Q2: Pitch Positioning** → Staff-space coordinate system with clef-aware mapping
3. **Q3: Horizontal Spacing** → Proportional (0.1 px/tick) with 15px minimum spacing
4. **Q4: SVG Performance** → Virtual scrolling with 200px buffer, memoization
5. **Q5: React Architecture** → Container/presentational + pure layout service

**Status**: ✅ All technical unknowns resolved

---

## Phase 1: Design (COMPLETE)

**Output**:
- `data-model.md` (600+ lines): TypeScript interfaces, algorithms, invariants
- `quickstart.md` (400+ lines): Developer onboarding guide with step-by-step implementation
- `contracts/`: NOT NEEDED (uses existing API)

**Data Model Highlights**:
- **Configuration**: StaffConfig with 12 tunable parameters
- **Geometry Types**: NotePosition, StaffLine, Barline, LedgerLine, ClefPosition, LayoutGeometry
- **Algorithms**: 8 layout functions with complete TypeScript implementations
- **SMuFL Codepoints**: Essential glyphs documented (U+E050 treble clef, U+E0A4 quarter note, etc.)
- **State Management**: React useState + useMemo pattern
- **Testing Strategy**: Unit tests for pure functions, integration tests for rendering

**Quickstart Highlights**:
- **Prerequisites**: TypeScript, React, SVG knowledge + 2-minute music notation primer
- **Setup**: Font download, CSS loading, directory structure
- **5-Phase Implementation**: Types (5min) → Layout Engine (10min) → Renderer (10min) → Coordinator (10min) → Integration (5min)
- **Verification Checklist**: Visual, interaction, and performance checks
- **Debugging Tips**: Common problems and fixes (font loading, positioning, performance)

**Status**: ✅ All design artifacts complete, ready for implementation

---

## Phase 2: Planning (COMPLETE)

**This Document**: plan.md

**Summary**:
- All technical context documented (language, dependencies, constraints, scale)
- Constitution check passed (5/5 principles)
- Project structure defined (frontend-only, 3 new directories)
- No complexity violations (no justification table needed)
- Research and design phases complete
- Ready for task generation (`/speckit.tasks` command)

**Status**: ✅ Planning phase complete

---

## Next Steps

1. **Generate Tasks**: Run `/speckit.tasks` command to create `tasks.md`
   - Break down implementation into atomic, testable units
   - Order tasks by dependency (types → service → components)
   - Each task includes test requirements (red-green-refactor)

2. **Implementation**: Follow Test-First workflow (Constitution V)
   - Write failing test first (red)
   - Implement minimum code to pass (green)
   - Refactor for clarity (refactor)
   - Commit only when tests pass

3. **Validation**: After implementation, verify success criteria (spec.md)
   - SC-001: Pitch identification <5 seconds
   - SC-002: Render 100 notes <500ms
   - SC-003: Positioning accuracy <1px error
   - SC-004: Selection response <50ms
   - SC-005: 1000 measures at 60fps

4. **Documentation**: Update README.md with feature description and screenshots

---

**Plan Status**: ✅ **COMPLETE**  
**Generated**: 2024-02-06  
**Branch**: 002-staff-notation-view  
**Ready For**: `/speckit.tasks` command
