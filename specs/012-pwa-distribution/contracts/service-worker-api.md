# Service Worker API Contract

**Feature**: 012-pwa-distribution  
**Date**: 2026-02-10

## Overview

This document defines the API contract for the Musicore service worker. The service worker acts as a network proxy between the web application and the backend, enabling offline functionality, caching strategies, and update management.

---

## 1. Service Worker Registration API

**Client-Side Registration** (main thread):
```typescript
/**
 * Register service worker and set up update listeners
 * @param swUrl - URL to service worker script (default: '/service-worker.js')
 * @param options - Registration options
 * @returns Promise<ServiceWorkerRegistration>
 */
async function registerServiceWorker(
  swUrl: string = '/service-worker.js',
  options?: RegistrationOptions
): Promise<ServiceWorkerRegistration>;

interface RegistrationOptions {
  scope?: string;              // Default: '/' (entire app)
  type?: 'classic' | 'module'; // Default: 'classic'
  updateViaCache?: 'imports' | 'all' | 'none'; // Default: 'imports'
}

// Example usage
const registration = await registerServiceWorker('/service-worker.js', {
  scope: '/',
  updateViaCache: 'none'  // Always check for updates
});
```

**Registration Events**:
```typescript
interface ServiceWorkerEventMap {
  // New service worker installing
  'updatefound': (registration: ServiceWorkerRegistration) => void;
  
  // Service worker state changed
  'statechange': (worker: ServiceWorker) => void;
  
  // Service worker controlling page
  'controllerchange': (navigator: ServiceWorkerContainer) => void;
}

// Example listeners
registration.addEventListener('updatefound', () => {
  const newWorker = registration.installing;
  console.log('Service worker update found');
});

navigator.serviceWorker.addEventListener('controllerchange', () => {
  console.log('New service worker activated, reloading page');
  window.location.reload();
});
```

---

## 2. Caching Strategy API

**Service Worker Implementation** (service-worker.ts):
```typescript
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

/**
 * Precache app shell (HTML, CSS, JS, WASM)
 * Automatically generated by vite-plugin-pwa during build
 */
precacheAndRoute(self.__WB_MANIFEST);

/**
 * Cache-First Strategy: App Shell
 * Serve from cache, fall back to network if not cached
 */
registerRoute(
  ({ request }) => request.destination === 'script' || 
                   request.destination === 'style' ||
                   request.destination === 'document',
  new CacheFirst({
    cacheName: 'musicore-app-shell-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 365 * 24 * 60 * 60,  // 1 year
      }),
    ],
  })
);

/**
 * Cache-First Strategy: WASM Module
 * Critical for offline operation
 */
registerRoute(
  ({ url }) => url.pathname.endsWith('.wasm'),
  new CacheFirst({
    cacheName: 'musicore-wasm-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 365 * 24 * 60 * 60,  // 1 year
      }),
    ],
  })
);

/**
 * Network-First Strategy: Score Data
 * Try network first (fresh data), fall back to cache if offline
 */
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/scores') ||
               url.pathname.endsWith('.musicxml'),
  new NetworkFirst({
    cacheName: 'musicore-scores-v1',
    networkTimeoutSeconds: 3,  // Fall back to cache after 3s
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,          // LRU: Keep 50 most recent scores
        maxAgeSeconds: 7 * 24 * 60 * 60,  // 7 days
        purgeOnQuotaError: true, // Auto-evict if quota exceeded
      }),
    ],
  })
);

/**
 * Stale-While-Revalidate Strategy: UI Assets
 * Serve cached version immediately, update cache in background
 */
registerRoute(
  ({ request }) => request.destination === 'image' ||
                   request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'musicore-assets-v1',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60,  // 30 days
      }),
    ],
  })
);
```

**Cache Naming Convention**:
```typescript
const CACHE_VERSION = '1.0.0';
const CACHE_PREFIX = 'musicore';

const CACHE_NAMES = {
  appShell: `${CACHE_PREFIX}-app-shell-v${CACHE_VERSION}`,
  wasm: `${CACHE_PREFIX}-wasm-v${CACHE_VERSION}`,
  scores: `${CACHE_PREFIX}-scores-v${CACHE_VERSION}`,
  assets: `${CACHE_PREFIX}-assets-v${CACHE_VERSION}`,
};
```

---

## 3. Service Worker Lifecycle API

**Install Event** (precaching):
```typescript
/**
 * Fired when service worker first installed
 * Used to precache app shell assets
 */
self.addEventListener('install', (event: ExtendableEvent) => {
  console.log('Service worker installing');
  
  event.waitUntil(
    // Precache critical assets
    caches.open(CACHE_NAMES.appShell).then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/src/main.tsx',
        '/src/App.css',
        '/musiccore_backend_bg.wasm',
      ]);
    })
  );
  
  // Optional: Skip waiting to activate immediately
  // self.skipWaiting();
});
```

**Activate Event** (cleanup):
```typescript
/**
 * Fired when service worker activated
 * Used to clean up old caches from previous versions
 */
self.addEventListener('activate', (event: ExtendableEvent) => {
  console.log('Service worker activating');
  
  event.waitUntil(
    (async () => {
      // Delete old caches
      const cacheNames = await caches.keys();
      await Promise.all(
        cacheNames
          .filter(name => name.startsWith(CACHE_PREFIX) && 
                          !Object.values(CACHE_NAMES).includes(name))
          .map(name => caches.delete(name))
      );
      
      // Take control of all pages immediately
      await self.clients.claim();
    })()
  );
});
```

**Fetch Event** (request interception):
```typescript
/**
 * Fired for every network request
 * Workbox handles this via registerRoute, but manual implementation:
 */
self.addEventListener('fetch', (event: FetchEvent) => {
  event.respondWith(
    caches.match(event.request).then((cachedResponse) => {
      // Return cached version if exists
      if (cachedResponse) {
        return cachedResponse;
      }
      
      // Otherwise fetch from network and cache
      return fetch(event.request).then((networkResponse) => {
        // Clone response (can only be consumed once)
        const responseToCache = networkResponse.clone();
        
        caches.open(CACHE_NAMES.scores).then((cache) => {
          cache.put(event.request, responseToCache);
        });
        
        return networkResponse;
      });
    })
  );
});
```

---

## 4. Update Management API

**Check for Updates** (client-side):
```typescript
/**
 * Manually check for service worker updates
 * @param registration - ServiceWorkerRegistration from registerServiceWorker
 */
async function checkForUpdates(
  registration: ServiceWorkerRegistration
): Promise<void> {
  await registration.update();
}

// Automatic update check on focus/visibility
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    const registration = await navigator.serviceWorker.ready;
    await checkForUpdates(registration);
  }
});

// Periodic update check (every 30 minutes)
setInterval(async () => {
  const registration = await navigator.serviceWorker.ready;
  await checkForUpdates(registration);
}, 30 * 60 * 1000);
```

**Skip Waiting** (activate new service worker immediately):
```typescript
/**
 * Message API: Client â†’ Service Worker
 * Tell waiting service worker to skip waiting and activate
 */
function skipWaitingAndReload(registration: ServiceWorkerRegistration): void {
  const waitingWorker = registration.waiting;
  
  if (!waitingWorker) {
    console.warn('No waiting service worker found');
    return;
  }
  
  // Listen for controller change (new SW activated)
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    window.location.reload();
  });
  
  // Tell waiting SW to skip waiting
  waitingWorker.postMessage({ type: 'SKIP_WAITING' });
}

/**
 * Service Worker Message Handler
 * Listen for SKIP_WAITING message from client
 */
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
```

**Update Notification Hook** (React hook):
```typescript
import { Workbox } from 'workbox-window';

interface UpdateState {
  updateAvailable: boolean;
  registration: ServiceWorkerRegistration | null;
}

/**
 * React hook for service worker update management
 * @returns Update state and update handler
 */
function useServiceWorkerUpdate(): [UpdateState, () => void] {
  const [state, setState] = React.useState<UpdateState>({
    updateAvailable: false,
    registration: null,
  });
  
  React.useEffect(() => {
    if ('serviceWorker' in navigator) {
      const wb = new Workbox('/service-worker.js');
      
      wb.addEventListener('waiting', (event) => {
        setState({
          updateAvailable: true,
          registration: event.sw as any,
        });
      });
      
      wb.register();
    }
  }, []);
  
  const applyUpdate = () => {
    if (state.registration) {
      skipWaitingAndReload(state.registration);
    }
  };
  
  return [state, applyUpdate];
}
```

---

## 5. Offline Sync API

**Queue Mutation** (when offline):
```typescript
interface QueuedMutation {
  id: string;
  type: 'CREATE' | 'UPDATE' | 'DELETE';
  entity: 'annotation' | 'score_metadata';
  data: any;
  timestamp: number;
  retryCount: number;
  pendingSync: boolean;
}

/**
 * Queue mutation in IndexedDB when offline
 * @param mutation - Mutation to queue
 */
async function queueMutation(mutation: Omit<QueuedMutation, 'id' | 'timestamp' | 'retryCount' | 'pendingSync'>): Promise<void> {
  const db = await openIndexedDB();
  const tx = db.transaction('offline_sync_queue', 'readwrite');
  const store = tx.objectStore('offline_sync_queue');
  
  await store.add({
    ...mutation,
    id: crypto.randomUUID(),
    timestamp: Date.now(),
    retryCount: 0,
    pendingSync: true,
  });
}

/**
 * Sync pending mutations when online
 */
async function syncPendingMutations(): Promise<void> {
  if (!navigator.onLine) {
    console.log('Cannot sync: offline');
    return;
  }
  
  const db = await openIndexedDB();
  const tx = db.transaction('offline_sync_queue', 'readonly');
  const store = tx.objectStore('offline_sync_queue');
  const index = store.index('pendingSync');
  const pendingMutations = await index.getAll(IDBKeyRange.only(true));
  
  for (const mutation of pendingMutations) {
    try {
      // POST to backend API
      await fetch('/api/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(mutation),
      });
      
      // Mark as synced
      const writeTx = db.transaction('offline_sync_queue', 'readwrite');
      const writeStore = writeTx.objectStore('offline_sync_queue');
      mutation.pendingSync = false;
      await writeStore.put(mutation);
    } catch (error) {
      console.error('Sync failed for mutation:', mutation.id, error);
      
      // Increment retry count
      const writeTx = db.transaction('offline_sync_queue', 'readwrite');
      const writeStore = writeTx.objectStore('offline_sync_queue');
      mutation.retryCount++;
      await writeStore.put(mutation);
    }
  }
}

// Sync on online event
window.addEventListener('online', () => {
  syncPendingMutations();
});
```

---

## 6. Cache Management API

**Get Cache Size**:
```typescript
/**
 * Calculate total cache storage size
 * @returns Size in bytes
 */
async function getCacheSize(): Promise<number> {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    return estimate.usage || 0;
  }
  return 0;
}

/**
 * Get cache storage quota
 * @returns Quota in bytes
 */
async function getCacheQuota(): Promise<number> {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    return estimate.quota || 0;
  }
  return 0;
}

/**
 * Calculate cache usage percentage
 */
async function getCacheUsagePercentage(): Promise<number> {
  const usage = await getCacheSize();
  const quota = await getCacheQuota();
  return quota > 0 ? (usage / quota) * 100 : 0;
}
```

**Clear Cache**:
```typescript
/**
 * Clear all Musicore caches (except app shell)
 * @param includeAppShell - Include app shell cache (requires reload)
 */
async function clearCache(includeAppShell: boolean = false): Promise<void> {
  const cacheNames = await caches.keys();
  
  await Promise.all(
    cacheNames
      .filter(name => {
        if (!name.startsWith(CACHE_PREFIX)) return false;
        if (!includeAppShell && name.includes('app-shell')) return false;
        return true;
      })
      .map(name => caches.delete(name))
  );
  
  if (includeAppShell) {
    window.location.reload();
  }
}
```

---

## 7. Install Prompt API

**Defer Install Prompt** (Chrome/Edge):
```typescript
let deferredPrompt: BeforeInstallPromptEvent | null = null;

interface BeforeInstallPromptEvent extends Event {
  prompt(): Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed'; platform: string }>;
}

/**
 * Capture install prompt for later use
 */
window.addEventListener('beforeinstallprompt', (e: Event) => {
  e.preventDefault();
  deferredPrompt = e as BeforeInstallPromptEvent;
  console.log('Install prompt deferred');
});

/**
 * Show install prompt
 * @returns User choice (accepted or dismissed)
 */
async function showInstallPrompt(): Promise<'accepted' | 'dismissed' | null> {
  if (!deferredPrompt) {
    console.warn('Install prompt not available');
    return null;
  }
  
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  deferredPrompt = null;
  
  return outcome;
}
```

**Detect Standalone Mode**:
```typescript
/**
 * Check if app is running in standalone mode (installed)
 * @returns true if installed as PWA
 */
function isStandaloneMode(): boolean {
  // Standard display-mode media query
  if (window.matchMedia('(display-mode: standalone)').matches) {
    return true;
  }
  
  // iOS-specific check
  if ((window.navigator as any).standalone === true) {
    return true;
  }
  
  return false;
}
```

---

## API Summary

| API | Purpose | Client or SW |
|-----|---------|--------------|
| **registerServiceWorker()** | Register service worker | Client |
| **precacheAndRoute()** | Precache app shell | SW |
| **registerRoute()** | Register caching strategy | SW |
| **checkForUpdates()** | Manual update check | Client |
| **skipWaitingAndReload()** | Apply update immediately | Client |
| **queueMutation()** | Queue offline mutation | Client |
| **syncPendingMutations()** | Sync queued mutations | Client |
| **getCacheSize()** | Get cache storage size | Client |
| **clearCache()** | Clear cached data | Client |
| **showInstallPrompt()** | Trigger install prompt | Client |
| **isStandaloneMode()** | Check if PWA installed | Client |

---

## Testing Contracts

**Service Worker Registration Test**:
```typescript
describe('Service Worker Registration', () => {
  it('should register service worker', async () => {
    const registration = await registerServiceWorker();
    expect(registration).toBeDefined();
    expect(registration.active).toBeDefined();
  });
  
  it('should update service worker when new version available', async () => {
    const registration = await navigator.serviceWorker.ready;
    await registration.update();
    expect(registration.waiting).toBeDefined();
  });
});
```

**Caching Strategy Test**:
```typescript
describe('Caching Strategies', () => {
  it('should cache app shell assets', async () => {
    const cache = await caches.open('musicore-app-shell-v1');
    const keys = await cache.keys();
    expect(keys.length).toBeGreaterThan(0);
  });
  
  it('should serve cached assets offline', async () => {
    const cachedResponse = await caches.match('/');
    expect(cachedResponse).toBeDefined();
    expect(cachedResponse?.status).toBe(200);
  });
});
```

**Update Flow Test**:
```typescript
describe('Service Worker Updates', () => {
  it('should detect new service worker version', async () => {
    const mockWorkbox = new Workbox('/service-worker.js');
    const waitingPromise = new Promise((resolve) => {
      mockWorkbox.addEventListener('waiting', resolve);
    });
    
    await mockWorkbox.register();
    await waitingPromise;
    
    expect(mockWorkbox.waiting).toBeDefined();
  });
  
  it('should activate new service worker on skip waiting', async () => {
    const registration = await navigator.serviceWorker.ready;
    const waitingWorker = registration.waiting;
    
    waitingWorker?.postMessage({ type: 'SKIP_WAITING' });
    
    await new Promise((resolve) => {
      navigator.serviceWorker.addEventListener('controllerchange', resolve);
    });
    
    expect(navigator.serviceWorker.controller).toBe(registration.active);
  });
});
```

---

## Error Handling

**Service Worker Registration Errors**:
```typescript
try {
  await registerServiceWorker();
} catch (error) {
  console.error('Service worker registration failed:', error);
  // Fallback: App works without service worker (no offline support)
}
```

**Cache Quota Exceeded**:
```typescript
try {
  await cache.put(request, response);
} catch (error) {
  if (error.name === 'QuotaExceededError') {
    console.warn('Cache quota exceeded, evicting old entries');
    // Workbox ExpirationPlugin handles this automatically
  }
}
```

**Fetch Failures**:
```typescript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => {
        // Network failed, try cache
        return caches.match(event.request);
      })
      .then((response) => {
        // Cache also failed, return offline fallback
        if (!response) {
          return caches.match('/offline.html');
        }
        return response;
      })
  );
});
```
