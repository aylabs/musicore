# Data Model: Offline Mode Parity

**Feature**: 025-offline-mode
**Purpose**: Document data structures, state management, and storage patterns for offline functionality
**Status**: Phase 1 Complete

## Overview

This feature does not introduce new data models — it removes network dependencies from existing data flows. The key data structures are:
1. Service Worker precache manifest (build artifact)
2. IndexedDB score storage (already implemented in Feature 011)
3. OfflineBanner component state (already implemented in Feature 011)
4. ScoreViewer component state (refactored to remove REST API usage)

No new entities, no new storage schemas. This is a **refactoring exercise** to eliminate network calls from local operations.

---

## Service Worker Precache Manifest

**Responsibility**: List of assets cached during service worker installation
**Lifecycle**: Generated at build time by Workbox, installed during first online visit
**Location**: Generated in `dist/sw.js` by Vite + vite-plugin-pwa

### Structure

```typescript
// Generated by Workbox at build time
// Location: dist/sw.js (precache manifest section)

const precacheManifest = [
  { url: '/index.html', revision: '...' },
  { url: '/assets/index-abc123.js', revision: null }, // hash in filename
  { url: '/assets/index-def456.css', revision: null },
  { url: '/wasm/musicore_backend.js', revision: null },
  { url: '/wasm/musicore_backend_bg.wasm', revision: null },
  { url: '/music/CanonD.musicxml', revision: '...' }, // ← NEW: demo file precached
  // ... other assets
];
```

**Key Properties**:
- `url`: Path to the asset (relative to site origin)
- `revision`: Content hash for cache invalidation (null if hash is in filename)

**Modification** (Decision 1 from research.md):
- Add `*.musicxml` to `vite.config.ts` → `VitePWA.workbox.globPatterns`
- Workbox automatically discovers all `.musicxml` files in `public/` directory
- Canon in D demo file (`public/music/CanonD.musicxml`) is included in precache

**Cache Strategy**: Cache-first (default for precached assets)
- First request: Service worker returns precached version instantly
- No network request needed offline

**Invalidation**: When the file content changes, Workbox updates the revision hash and the service worker updates the cache on next online visit.

---

## IndexedDB Score Storage (Existing)

**Responsibility**: Persist scores locally for offline access
**Lifecycle**: Scores saved when imported or when demo is loaded
**Location**: Browser IndexedDB database `musicore-db`, object store `scores`

### Schema

```typescript
// Defined in: frontend/src/services/storage/local-storage.ts
// Store name: 'scores'
// Key path: 'id' (score UUID)

interface Score {
  id: string;                    // UUID
  instruments: Instrument[];     // Full score hierarchy
  schema_version: number;        // For schema migration (currently 2)
  isDemoScore?: boolean;         // Flag marking demo scores (Feature 013)
  // ... full Score type from types/score.ts
}
```

**Operations** (no changes):
- `saveScoreToIndexedDB(score)`: Save/update a score
- `loadScoreFromIndexedDB(id)`: Retrieve a score by ID
- `getAllScoresFromIndexedDB()`: List all scores (filters by schema version)
- `deleteScoreFromIndexedDB(id)`: Delete a score

**Offline Behavior**:
- All operations work identically offline and online (IndexedDB is local storage)
- No network requests involved

**Change Impact**: None — IndexedDB layer already works offline. This feature removes REST API fallbacks that competed with IndexedDB.

---

## OfflineBanner Component State (Existing)

**Responsibility**: Display banner when browser is offline
**Lifecycle**: Renders when `navigator.onLine === false`
**Location**: `frontend/src/components/OfflineBanner.tsx`

### State

```typescript
// Hook: frontend/src/hooks/useOfflineDetection.ts
export function useOfflineDetection(): boolean {
  const [isOnline, setIsOnline] = useState<boolean>(navigator.onLine);
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
}

// Component internal state: none (no dismissal state yet)
```

**Modification** (Decision 3 from research.md):
- Update message text: `"You're offline — all features work normally"`
- No state changes needed

**Display Logic**:
- Banner visible when `isOnline === false`
- Banner hidden when `isOnline === true`
- Auto-updates on `online`/`offline` events from browser

---

## ScoreViewer Component State (Refactored)

**Responsibility**: Main score viewing/interaction component
**Lifecycle**: Mounted when a score is displayed
**Location**: `frontend/src/components/ScoreViewer.tsx`

### Current State (problematic)

```typescript
// Current implementation (Feature 014 + prior)
interface ScoreViewerState {
  score: Score | null;
  scoreId: string | undefined;
  loading: boolean;
  error: string | null;
  successMessage: string | null;
  skipNextLoad: boolean;
  isFileSourced: boolean;           // Track if score came from file
  shouldAutoPlay: boolean;          // Auto-play demo after load
  // ... other state for playback, view mode, etc.
}

// Problematic data flows:
// 1. loadScore() → try IndexedDB → fall back to apiClient.getScore() ❌ fails offline
// 2. handleMusicXMLImport() → syncLocalScoreToBackend() → 10+ REST calls ❌ fails offline
// 3. createNewScore() → apiClient.createScore() ❌ fails offline (legacy path)
```

### Refactored State (offline-safe)

```typescript
// Refactored implementation (Feature 025)
interface ScoreViewerState {
  score: Score | null;
  scoreId: string | undefined;
  loading: boolean;
  error: string | null;
  successMessage: string | null;
  skipNextLoad: boolean;
  isFileSourced: boolean;           // Retain: still useful for local vs IndexedDB distinction
  shouldAutoPlay: boolean;
  // No new state fields added — only logic changes
}

// Fixed data flows:
// 1. loadScore() → IndexedDB only → show "Score not found" if missing (no REST fallback)
// 2. handleMusicXMLImport() → save to IndexedDB → done (no backend sync)
// 3. createNewScore() → WASM createScore() → save to IndexedDB (no REST call)
```

**Removed Functions**:
- `syncLocalScoreToBackend()` — deleted entirely (Decision 2)
- REST API fallback in `loadScore()` — removed

**Modified Functions**:
- `loadScore(id)`: Only tries IndexedDB. If not found, sets `error` with clear message.
- `handleMusicXMLImport(result)`: WASM parse → save to IndexedDB → done. No sync calls.
- `createNewScore()`: Calls WASM `createScore()` instead of `apiClient.createScore()`.

**State Transitions**:

```text
Import Flow (before vs after):
────────────────────────────────
[Before - Feature 014]
User selects file
  → WASM parse
  → Save to IndexedDB
  → Trigger syncLocalScoreToBackend() ← NETWORK CALLS (fails offline)
  → Display score

[After - Feature 025]
User selects file
  → WASM parse
  → Save to IndexedDB
  → Display score
  (no backend sync)


Demo Load Flow (before vs after):
──────────────────────────────────
[Before - Feature 013]
User taps "Demo"
  → DemoLoaderService.loadBundledDemo()
  → fetch('/music/CanonD.musicxml') ← NETWORK CALL (fails first offline visit)
  → WASM parse
  → Save to IndexedDB
  → Display score

[After - Feature 025]
User taps "Demo"
  → DemoLoaderService.loadBundledDemo()
  → Check IndexedDB for existing demo
  → If not found, load from service worker cache (precached file)
  → WASM parse
  → Save to IndexedDB
  → Display score
  (no fetch() call — file comes from cache)


Score Load Flow (before vs after):
───────────────────────────────────
[Before]
User navigates to score ID
  → Try IndexedDB
  → If not found: apiClient.getScore(id) ← NETWORK CALL (fails offline)
  → Display score or error

[After]
User navigates to score ID
  → Try IndexedDB
  → If not found: show "Score not found — import from file" message
  → No network fallback
```

---

## DemoLoaderService Refactoring

**Responsibility**: Load Canon in D demo from precached MusicXML
**Lifecycle**: Called when user taps "Demo" button
**Location**: `frontend/src/services/onboarding/demoLoader.ts`

### Current Implementation (problematic)

```typescript
// Current method (Feature 013)
class DemoLoaderService {
  private demoBundlePath = `${import.meta.env.BASE_URL}music/CanonD.musicxml`;
  
  async loadBundledDemo(): Promise<DemoScoreMetadata> {
    // 1. Fetch from server (fails on first offline visit)
    const response = await fetch(this.demoBundlePath); // ❌ network call
    if (!response.ok) throw new Error('Fetch failed');
    
    const musicXML = await response.text();
    
    // 2. Parse via WASM
    const wasmResult = await parseMusicXML(musicXML);
    
    // 3. Save to IndexedDB
    const score = { ...wasmResult.score, isDemoScore: true };
    await saveScoreToIndexedDB(score);
    
    return score as DemoScoreMetadata;
  }
}
```

### Refactored Implementation (offline-safe)

```typescript
// Refactored method (Feature 025)
class DemoLoaderService {
  private demoBundlePath = `${import.meta.env.BASE_URL}music/CanonD.musicxml`;
  
  async loadBundledDemo(): Promise<DemoScoreMetadata> {
    // 1. Check if demo already exists in IndexedDB (fast path)
    const existingDemo = await this.getExistingDemo();
    if (existingDemo) {
      console.log('[DemoLoader] Demo already in IndexedDB');
      return existingDemo;
    }
    
    // 2. Load from service worker cache (precached during install)
    //    Note: fetch() here hits the service worker cache, not the network
    //    Service worker returns cached file instantly
    const response = await fetch(this.demoBundlePath); // ✅ cache hit (offline-safe)
    if (!response.ok) {
      // This only fails if:
      // a) User never visited online (service worker not installed)
      // b) Service worker cache was cleared
      throw new Error('Demo file not available — visit online first');
    }
    
    const musicXML = await response.text();
    
    // 3. Parse via WASM
    const wasmResult = await parseMusicXML(musicXML);
    
    // 4. Save to IndexedDB for future fast path
    const score = { ...wasmResult.score, isDemoScore: true };
    await saveScoreToIndexedDB(score);
    
    return score as DemoScoreMetadata;
  }
  
  private async getExistingDemo(): Promise<DemoScoreMetadata | null> {
    const allScores = await getAllScoresFromIndexedDB();
    return allScores.find(s => s.isDemoScore === true) || null;
  }
}
```

**Key Changes**:
- `fetch()` call remains, but now hits service worker cache (not network)
- Added IndexedDB fast path: if demo was loaded before, skip fetch entirely
- Clear error message if precache not available (requires online visit first)

**Offline Behavior**:
1. **First demo load after online visit**: `fetch()` returns cached file → WASM parse → IndexedDB save → display
2. **Subsequent demo loads**: IndexedDB fast path → display (no fetch needed)
3. **First demo load on first offline visit**: Fails with clear error (expected — service worker not installed yet)

---

## Data Flow Diagrams

### Demo Load Flow (Offline-Safe)

```text
User taps "Demo"
    ↓
DemoLoaderService.loadBundledDemo()
    ↓
Check IndexedDB for existing demo
    ↓
┌───────────────────────┐
│ Demo exists?          │
└───────────────────────┘
    Yes ↓          No ↓
    ↓              ↓
    └─→ Return     fetch('/music/CanonD.musicxml')
        from          ↓
        IndexedDB  Service Worker intercepts
                      ↓
                   Return from precache (cache-first)
                      ↓
                   WASM parse (parseMusicXML)
                      ↓
                   Save to IndexedDB (with isDemoScore: true)
                      ↓
                   Return score
                      ↓
                   ↓
ScoreViewer displays notation
```

### Import Flow (Offline-Safe)

```text
User selects MusicXML file
    ↓
File → ArrayBuffer
    ↓
WASM parseMusicXML(bytes)
    ↓
ImportResult { score, warnings }
    ↓
Save to IndexedDB (saveScoreToIndexedDB)
    ↓
Update ScoreViewer state (setScore, setScoreId)
    ↓
Display notation
(no backend sync — no network calls)
```

### Score Load Flow (Offline-Safe)

```text
User navigates to /score/:id
    ↓
ScoreViewer.loadScore(id)
    ↓
loadScoreFromIndexedDB(id)
    ↓
┌──────────────────────┐
│ Score found?         │
└──────────────────────┘
    Yes ↓      No ↓
    ↓          ↓
    └─→ Display  setError("Score not found — import from file")
        score
        
(no REST API fallback — no network calls)
```

---

## Storage Boundaries

### What Lives Where

| Data | Storage Location | Offline Available? | Cleared When? |
|------|------------------|-------------------|---------------|
| **App shell** (HTML, CSS, JS) | Service Worker cache | ✅ Yes (cache-first) | Service worker uninstall or manual cache clear |
| **WASM module** | Service Worker cache | ✅ Yes (cache-first) | Service worker uninstall or manual cache clear |
| **Demo MusicXML** | Service Worker cache (NEW) | ✅ Yes (cache-first) | Service worker uninstall or manual cache clear |
| **Imported scores** | IndexedDB | ✅ Yes (persistent) | Manual deletion by user or browser storage clear |
| **Demo score (parsed)** | IndexedDB | ✅ Yes (persistent) | Manual deletion by user or browser storage clear |
| **User settings** | localStorage (existing) | ✅ Yes (persistent) | Browser storage clear |
| **Playback state** | Component state (React) | ❌ No (in-memory) | Page reload |

**Critical Insight**: After this feature, **zero data depends on network**. Everything needed for offline operation is either:
1. Precached by service worker during install (app shell, WASM, demo)
2. Persisted in IndexedDB (user-imported scores, parsed demo)
3. In local browser storage (user preferences)

---

## Summary

**New Data Structures**: None

**Modified Data Flows**:
1. Demo loading: Added precache → now works on first offline visit after online install
2. Score import: Removed backend sync → now pure local operation (WASM + IndexedDB)
3. Score loading: Removed REST fallback → now IndexedDB-only with clear "not found" error
4. Banner messaging: Updated text → clearer offline status

**Storage Impact**: ~50KB additional cache for demo MusicXML (negligible)

**State Complexity**: Reduced — fewer failure modes, fewer code paths, clearer errors
